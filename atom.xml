<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>姜兴业非官方网站</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://jiangxingye.github.io/"/>
  <updated>2019-09-17T03:20:24.984Z</updated>
  <id>https://jiangxingye.github.io/</id>
  
  <author>
    <name>姜兴业</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="https://jiangxingye.github.io/2019/09/16/ubuntu%E7%B3%BB%E7%BB%9F%E4%B8%8B%E5%AE%89%E8%A3%85cuda%E5%92%8Ccudnn%E9%A9%B1%E5%8A%A8%E6%96%B9%E6%B3%95/"/>
    <id>https://jiangxingye.github.io/2019/09/16/ubuntu系统下安装cuda和cudnn驱动方法/</id>
    <published>2019-09-16T01:22:01.476Z</published>
    <updated>2019-09-17T03:20:24.984Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Ubuntu-16-04-系统下安装-cuda-驱动方法"><a href="#Ubuntu-16-04-系统下安装-cuda-驱动方法" class="headerlink" title="Ubuntu 16.04 系统下安装 cuda 驱动方法"></a>Ubuntu 16.04 系统下安装 cuda 驱动方法</h1><h2 id="一、cuda-install"><a href="#一、cuda-install" class="headerlink" title="一、cuda install"></a>一、cuda install</h2><ol><li>cuda 包含nvidia 显卡驱动 ，如果事先安装好了 nvidia 显卡驱动，在安装 cuda<br>的时候提示安装 nvidia 显卡驱动时候选择 no，不用安装显卡驱动。</li><li>cuda 下载链接：<a href="https://developer.nvidia.com/cuda-toolkit" target="_blank" rel="noopener">https://developer.nvidia.com/cuda-toolkit</a></li><li>cuda 安装前准备</li></ol><h3 id="二、禁用-ubuntu-系统自带的nvidia-第三方驱动：nouveau"><a href="#二、禁用-ubuntu-系统自带的nvidia-第三方驱动：nouveau" class="headerlink" title="二、禁用 ubuntu 系统自带的nvidia 第三方驱动：nouveau"></a>二、禁用 ubuntu 系统自带的nvidia 第三方驱动：nouveau</h3><p>禁用方法：</p><ol><li><p>编译/etc/modprobe.d/blacklist.conf</p></li><li><p>nano /etc/modprobe.d/blacklist.conf</p></li><li><p>在配置文件的最后一页贴加如下命令。</p><p>blacklist nouveau</p><p>options nouveau modeset=0</p></li><li><p>贴加完毕后按ctrl+x 保存 选 y 保存，然后回车即可退出编译界面。</p></li><li><p>执行命令加载文件： update-initramfs –u</p></li><li><p>重启机器 执行：lsmod | grep nouveau 命令，如果屏幕没有输出，说明禁用<br>nouveau 成功。</p><h2 id="三、禁用-X-Window-服务"><a href="#三、禁用-X-Window-服务" class="headerlink" title="三、禁用 X-Window 服务"></a>三、禁用 X-Window 服务</h2><p>首先用命令：service lightdm stop 禁用图形界面</p><p>然后用命令 Ctrl-Alt+F1 进入命令行界面，输入用户名和密码登录</p></li></ol><p>安装 cuda</p><ol><li><p>把 cuda 驱动拷贝到根目录下， 然后进入到根目录下面， 记住要 root 权限<br>安装 。用命令:./cuda.xxx.run -no-opengl-libs 安装</p></li><li><p>进入安装界面，首先阅读安装说明，可以用 ctrl+c 跳过，也可以用空格<br>一个个的看完。一般直接忽略。</p></li><li><p>进入安装，第一个问题:选择接受 accept，第二个问题:问是否安装 nvidia<br>显卡驱动？ 如果事前安装了驱动，可以选择 no，不然后就选者 yes<br>。然后第三个问题及后面的问题都选择 yes。没有 yes/no 选择的<br>用回车默认就可以了。</p></li></ol><p><img src="/2019/09/16/ubuntu系统下安装cuda和cudnn驱动方法/890c8c55b96dc29f109a2930ac1a16c6.jpg" alt>Cuda 安装完毕。</p><h3 id="四、设置环境变量："><a href="#四、设置环境变量：" class="headerlink" title="四、设置环境变量："></a>四、设置环境变量<strong>：</strong></h3><p>终端中输入 ：sudo gedit /etc/profile 在打开的文件末尾，添加以下两行。</p><pre><code>export PATH=/usr/local/cuda-10.1/bin:\$PATHexport LD_LIBRARY_PATH=/usr/local/cuda-10.1/lib64:\$LD_LIBRARY_PATH</code></pre><p>保存文件，并重启。因为 source /etc/profile是临时生效，重启电脑才是永久生效。</p><h3 id="五、重启电脑，检查上述的环境变量是否设置成功"><a href="#五、重启电脑，检查上述的环境变量是否设置成功" class="headerlink" title="五、重启电脑，检查上述的环境变量是否设置成功"></a><strong>五、</strong>重启电脑，检查上述的环境变量是否设置成功</h3><ol start="2"><li>a、 验证驱动版本敲入</li></ol><pre><code>$ cat /proc/driver/nvidia/version 结果显示NVRM version: NVIDIA UNIX x86_64 Kernel Module 384.81 Sat Sep 2 02:43:11 PDT2017GCC version: gcc version 5.4.0 20160609 (Ubuntu 5.4.0-6ubuntu1\~16.04.5)</code></pre><p>b、 验证 CUDA Toolkit 敲入</p><p>$ nvcc -V 会输出 CUDA</p><p>版本信息</p><p>如果是这样的：</p><p>The program ‘nvcc’ is currently not installed. You can install it by typing:<br>sudo apt-get install nvidia-cuda-toolkit。</p><p>可能是环境配置没有成功，请重复上述步骤 7</p><ol><li>测试 CUDA 的 Samples 例子</li></ol><blockquote><p>  运行下面命令：</p></blockquote><pre><code>cd /usr/local/cuda-9.0/samples/1_Utilities/deviceQuery make</code></pre><pre><code>./deviceQuerycd /usr/local/cuda-9.0/samples/1_Utilities/bandwidthTest Make./ bandwidthTest</code></pre><p>测试成功会显示结果：pass</p><h1 id="六、Cuda-安装成功。"><a href="#六、Cuda-安装成功。" class="headerlink" title="六、Cuda 安装成功。"></a>六、Cuda 安装成功。</h1><blockquote><p>  Cuda 安装参考文档及一些常用问题参考此链接：<br>  <em><a href="http://blog.csdn.net/qlulibin/article/details/78714596" target="_blank" rel="noopener">http://blog.csdn.net/qlulibin/article/details/78714596</a></em></p></blockquote><ol><li><p>cuda 安装完后，安装 cudnn</p><ol><li>先去 nvidia 官网下载 cudnn，cudnn<br>下载需要注册账号才能安登陆进去下载。网站：<em><a href="https://developer.nvidia.com/cudnn" target="_blank" rel="noopener">https://developer.nvidia.com/cudnn</a></em></li></ol></li></ol><p><img src="/2019/09/16/ubuntu系统下安装cuda和cudnn驱动方法/67ced510ecc00b4ede3098611c9086e0.png" alt></p><ol><li>先登录，然后同意下载，然后选择自己需要 cudnn 下载</li></ol><p><img src="/2019/09/16/ubuntu系统下安装cuda和cudnn驱动方法/2c8cc9e129b45e225dc9705bc4794824.jpg" alt></p><ol><li><p>点击下载 tar 的压缩包，然厚把压缩包拷贝到系统下，然后进入到对应目录</p></li><li><p>执行下面命令，开始安装。</p></li></ol><blockquote><pre><code>  &gt; tar -zxvf cudnn-7.5-linux-x64-v5.0-ga.tgz  &gt; cp cuda/include/cudnn.h /usr/local/cuda/include/ cp cuda/lib64/libcudnn\*  &gt; /usr/local/cuda/lib64/ chmod a+r /usr/local/cuda/include/cudnn.h chmod a+r  &gt; /usr/local/cuda/lib64/libcudnn\*</code></pre></blockquote><ol><li>Cudnn 安装完毕。</li></ol><blockquote><p>  备注：cudnn 的版本需要和 cuda 的版本是要在兼容范围内，若果不兼容，会报错的。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>How to visit Google like drinking water</title>
    <link href="https://jiangxingye.github.io/2019/09/12/How%20to%20visit%20Google%20like%20drinking%20water/"/>
    <id>https://jiangxingye.github.io/2019/09/12/How to visit Google like drinking water/</id>
    <published>2019-09-12T09:10:52.000Z</published>
    <updated>2019-09-12T09:20:33.237Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="How-to-visit-Google-like-drinking-water"><a href="#How-to-visit-Google-like-drinking-water" class="headerlink" title="How to visit Google like drinking water"></a>How to visit Google like drinking water</h1><p>我也是无意中发现的一个网站，还挺好用的呢。^_^</p><p><a href="https://5414.ml" target="_blank" rel="noopener">点我访问</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="it" scheme="https://jiangxingye.github.io/categories/it/"/>
    
      <category term="network" scheme="https://jiangxingye.github.io/categories/it/network/"/>
    
    
      <category term="科学上网" scheme="https://jiangxingye.github.io/tags/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>how to install os &amp; install NVIDIA Driver</title>
    <link href="https://jiangxingye.github.io/2019/09/11/how%20to%20install%20os%20&amp;%20install%20NVIDIA%20Driver/"/>
    <id>https://jiangxingye.github.io/2019/09/11/how to install os &amp; install NVIDIA Driver/</id>
    <published>2019-09-11T10:16:49.000Z</published>
    <updated>2019-09-12T03:23:21.145Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="一-安装Ubuntu"><a href="#一-安装Ubuntu" class="headerlink" title="一.安装Ubuntu"></a><strong>一.安装Ubuntu</strong></h1><p>1.制作启动盘，选择启动盘启动，硬盘分区自己分，然后按步安装就行就行了。</p><h1 id="二-修改主机名和root密码"><a href="#二-修改主机名和root密码" class="headerlink" title="二.修改主机名和root密码"></a><strong>二.修改主机名和root密码</strong></h1><p>vim     /etc/hostname 与vim /etc/hosts/(ip域名)</p><p>sudo passwd root</p><h1 id="三-网络配置"><a href="#三-网络配置" class="headerlink" title="三.网络配置"></a><strong>三.网络配置</strong></h1><p>vim /etc/network/interfaces</p><p>自动获取：</p><p>auton eno2</p><p>iface eno2 inet dhcp</p><p>设置静态地址：</p><p>auto eno2</p><p>iface eno2 inet static</p><p>address <strong><strong>****</strong></strong></p><p>netmask 255.255.255.0 </p><p>gateway：<strong><strong>*****</strong></strong></p><p>重启网络服务：</p><p>1.service network restart</p><p>2./etc/init.d/networking restart</p><p>3.ifdown / ifup</p><p>配置dns</p><p>vim /etc/resolv.conf</p><h1 id="四-NVIDIA驱动安装"><a href="#四-NVIDIA驱动安装" class="headerlink" title="四.NVIDIA驱动安装"></a><strong>四.NVIDIA驱动安装</strong></h1><p>1.删除旧的驱动：</p><p>sudo apt-get purge nvidia*</p><p>2.关闭nouveau</p><p>查看属性 </p><p>sudo ls -lh /etc/modprobe.d/blacklist.conf</p><p>修改属性 </p><p>sudo chmod 666 /etc/modprobe.d/blacklist.conf</p><p>禁用：</p><p>vim /etc/modprobe.d/blacklist.conf</p><p>添加：</p><p>blacklist vga16fb</p><p>blacklist nouveau</p><p>blacklist rivafb</p><p>blacklist rivatv</p><p>blacklist nvidiafb</p><p>options nouveau modeset=0——如果禁用不成功就加上这句，不行就重启</p><p>更新：</p><p>sudo update-initramfs -u</p><p>重启查看：</p><p> lsmod | grep nouveau</p><p>关闭图形界面：</p><p>init 3 或 sudo service lightdw stop</p><p>安装 ：</p><p> sudo chmod +x NVIDIA-Linux-x86_64-***run</p><p>sudo sh NVIDIA-Linux-x86_64-xxx.run -no-x-check -no-nouveau-check -no-opengl-files或sudo ./NVIDIA-Linux-x86_64-xxx.run -no-x-check -no-nouveau-check -no-opengl-files(避免出现循环登录)</p><p>安装gcc g++ make（不然可能报错）</p><p>apt-get install gcc</p><p>apt-get install g++</p><p>apt-get install make</p><p>查看:</p><p>nvidia-smi或nvidia-settings</p><p>卸载：</p><p>sudo sh ~/NVIDIA-Linux-x86_64-**.run –uninstall</p><p>驱动安装启动不了界面问题解决：</p><p>把/etc/lightdm/lightdm.conf备份</p><p>把/etc/x11/下面的xorg.conf.failsafe文件复制成xorg.conf</p><p>关闭集显</p><h1 id="五-安装cuda9-1及cudnn7——关闭NetworkManager（不然重启可能进不去命令行）"><a href="#五-安装cuda9-1及cudnn7——关闭NetworkManager（不然重启可能进不去命令行）" class="headerlink" title="五.安装cuda9.1及cudnn7——关闭NetworkManager（不然重启可能进不去命令行）"></a><strong>五.安装cuda9.1及cudnn7——</strong>关闭NetworkManager（不然重启可能进不去命令行）</h1><p>下载runfile文件</p><p>关闭图形界面</p><p>验证系统是否安装了kernel header和 package development</p><p>uname -rsudo apt-get install linux-headers-$(uname -r)——可省略的操作</p><p>安装：</p><p>sudo sh cuda_9.1.85_387.26_linux.run</p><p>配置环境：</p><p>vim /etc/profile </p><p>export PATH=/usr/local/cuda-9.1/bin:$PATH</p><p>export LD_LIBRARY_PATH=/usr/local/cuda-9.1/lib64:$LD_LIBRARY_PATH</p><p>不行的话试试：</p><p>vim ~/.bashrc</p><p>$ export PATH=/usr/local/cuda-9.1/bin${PATH:+:{PATH}}$ export LD_LIBRARY_PATH=/usr/local/cuda-9.1/lib64${LD_LIBRARY_PATH:+:{LD_LIBRARY_PATH}}</p><p>vim /etc/p rofile </p><p>export PATH=/usr/local/cuda-9.1/bin:$PATH</p><p>链接文件：</p><p>vim /etc/ld.so.conf.d/cuda.conf</p><p>/usr/local/cuda/lib64</p><p>sudo lsconfig</p><p>.查看：</p><p>nvcc –version</p><p>cudnn安装——和cuda一个路径</p><p>tar -zxvf <strong>**</strong></p><p>cd  cuda/</p><p>sudo cp lib64/libcudnn*  /usr/local/cuda-9.1/lib64/</p><p>sudo cp include/cudnn.h  /usr/local/cuda-9.1/include/</p><p>更新网络连接：</p><p>cd /usr/local/cuda-9.1/lib64/</p><p>chmod +r libcudnn.so.7.1.1 ——主要看版本</p><p>sudo ln -sf libcudnn.so.7.1.1 libcudnn.so.7</p><p>sudo ln -sf libcudnn.so.7  libcudnn.so</p><p>链接文件：</p><p>vim /etc/ld.so.conf.d/cuda.conf</p><p>/usr/local/cuda-9.1/lib64</p><p>查看成功安装与否:ls /usr/local/cuda-9.0/lib64/libcudnn*</p><p>sudo ldconfig</p><h1 id="六-安装docker——一定要跟更新apt-get"><a href="#六-安装docker——一定要跟更新apt-get" class="headerlink" title="六.安装docker——一定要跟更新apt-get"></a><strong>六.安装docker——一定要跟更新apt-get</strong></h1><p>更新apt-get</p><p>apt-get  update</p><p>通过HTTP使用存储库：</p><p>sudo apt-get install -y apt-transport-https ca-certificates curl software-properties-common——可不用加</p><p>添加密钥</p><p>curl -fsSL <a href="https://download.docker.com/linux/ubuntu/gpg" target="_blank" rel="noopener">https://download.docker.com/linux/ubuntu/gpg</a> | sudo apt-key add -</p><p>设置stable存储库</p><p>sudo add-apt-repository “deb [arch=amd64] <a href="https://download.docker.com/linux/ubuntu" target="_blank" rel="noopener">https://download.docker.com/linux/ubuntu</a> $(lsb_release -cs) stable”</p><p>在更新：</p><p>sudo apt-get update</p><p>安装最新的docker社区版</p><p>sudo apt-get install -y docker-ce</p><p>测试：</p><p>sudo docker run hello-world</p><p>列出可用的版本：</p><p>$ apt-cache madison docker-ce</p><p>下载nvidia-docker源文件：</p><p>wget <a href="https://github.com/nvidia/nvidia-docker/releases/download/v1.0.1/nvidia-docker_1.0.1-1_amd.deb" target="_blank" rel="noopener">https://github.com/nvidia/nvidia-docker/releases/download/v1.0.1/nvidia-docker_1.0.1-1_amd.deb</a>  <a href="https://github.com/nvidia/nvidia-docker/releases/download/v1.0.1/nvidia-docker_1.0.1-1_amd.deb" target="_blank" rel="noopener">https://github.com/NVIDIA/nvidia-docker/releases/download/v1.0.1/nvidia-docker_1.0.1-1_amd64.deb</a> </p><p> ——注：如果下载不了就用优盘拷贝进去</p><p>安装nvidia-docker</p><p>dpck -i nvidia-docker*.deb</p><p>验证：</p><p>systemctl start docker或 service docker start</p><p>docker images</p><p>docker –version</p><p>docker run hello-world</p><h1 id="七-caffe安装"><a href="#七-caffe安装" class="headerlink" title="七.caffe安装"></a><strong>七.caffe安装</strong></h1><p>依赖库安装：</p><p>sudo apt-get install libprotobuf-dev libleveldb-dev libsnappy-dev libopencv-dev libhdf5-serial-dev protobuf-compiler libgflags-dev libgoogle-glog-dev liblmdb-dev libatlas-base-dev git </p><p>sudo apt-get install –no-install-recommends libboost-all-dev</p><p>如果不行可加上这些依赖项：（cmake build-essential libopenblas-dev liblapack-dev）</p><p>安装NCCL：</p><p>git clone <a href="https://github.com/NVIDIA/nccl.git" target="_blank" rel="noopener">https://github.com/NVIDIA/nccl.git</a></p><p>cd nccl</p><p>sudo make install -j8</p><p>安装caffe：</p><p>wget <a href="https://github.com/NVIDIA/caffe/archive/v0.15.9.tar.gz" target="_blank" rel="noopener">https://github.com/NVIDIA/caffe/archive/v0.15.9.tar.gz</a> /opt</p><p>tar zxvf v0.15.9.tar.g z</p><p>cd caffe-0.15.9</p><p>cp Makefile,config.example Makefile.config</p><p>vim Makefile.config</p><p>取消 USE_CUDNN:=1的注释和取消USE_NCCL:=1的注释</p><p>编译：</p><p>make all -j12</p><p>出现问题：</p><p>1.找不到目录caffe hdf5</p><p>解决：vim Makefile.config</p><p>85行：INCLUDE_DIRS 后面添加 /usr/include/hdf5/serial/</p><p>vim Makefile</p><p>173行： LIBRARIES+=中的hdf5_hl和hdf5改为hdf5_serial_hl和hdf5_serial</p><p>2.Unsupport<strong><strong>***</strong></strong>“compute 20“</p><p>解决：因为安装的是cuda9.1所以vim Makefile.config中CUDA_ARCH</p><p>删除20和21结尾的两行</p><p>测试：</p><p>sudo make runtest -j8</p><p>验证：</p><p> /build/tools<strong>*****</strong></p><p>最后把caffe的环境变量加入到etc profile</p><p>vim /etc/profile </p><p>eaport PATH= /opt/caffe-0.15.9/build/tools :$PATH</p><p><strong>cudnn.hpp问题：</strong></p><p>因为当前版本的caffe的cudnn实现与系统所安装的cudnn的版本不一致引起的。</p><p>解决办法：</p><p>1.将./include/caffe/util/cudnn.hpp 换成最新版的caffe里的cudnn的实现，即相应的cudnn.hpp.</p><p>\2. 将./include/caffe/layers里的，所有以cudnn开头的文件，例cudnn_conv_layer.hpp。   都替换成最新版的c affe里的相应的同名文件。</p><p>3.将./src/caffe/layer里的，所有以cudnn开头的文件，例如cudnn_lrn_layer.cu，cudnn_pooling_layer.cpp，cudnn_sigmoid_layer.cu。都替换成最新版的caffe里的相应的同名文件。</p><p><a href="https://blog.csdn.net/u014696921/article/details/56014899" target="_blank" rel="noopener">https://blog.csdn.net/u014696921/article/details/56014899</a></p><p>编译错误：</p><p>.build_release/examples/siamese/convert_mnist_siamese_data.bin </p><p>解决方法：</p><p>首先这个问题确实是opencv的问题，只需要把  Makefile.config里的    #USE_PKG_CONFIG := 这一行前面的#给去掉，然后在他下一行添加</p><p>LIBRARIES += glog gflags protobuf leveldb snappy \</p><p>​        lmdb boost_system hdf5_hl hdf5 m \</p><p>​        opencv_core opencv_highgui opencv_imgproc opencv_imgcodecs</p><p>保存，然后再编译即可。如果还不可以，试一下把原来的编译内容用make clean清空，再重新编译。如果还不行，那只能靠诸位再继续大胆尝试了。</p><h1 id="八-安装Anaconda"><a href="#八-安装Anaconda" class="headerlink" title="八.安装Anaconda"></a><strong>八.安装Anaconda</strong></h1><p>应用软件安装在/opt目录下：</p><p>bash Anaconda………………..</p><p>添加环境：export PATH=………..：/opt/anaconda3/bin:$PATH</p><p>source /etc/profile</p><p>验证:</p><p>conda list</p><p>配置好PATH后，可以通过which conda或conda –version命令检查是否正确。 </p><p>输入conda list 就可以查询，你现在安装了哪些库，常用的numpy, scipy名列其中。如果你还有什么包没有安装上，可以运行conda install * 来进行安装， </p><p>如果某个包版本不是最新的，运行 conda update * 就可以了。</p><h1 id="九-安装tensorflow——目前只有cuda9-0可以匹配tensorflow1-8和1-9，cuda9-1版本太高"><a href="#九-安装tensorflow——目前只有cuda9-0可以匹配tensorflow1-8和1-9，cuda9-1版本太高" class="headerlink" title="九.安装tensorflow——目前只有cuda9.0可以匹配tensorflow1.8和1.9，cuda9.1版本太高"></a><strong>九.安装tensorflow——</strong>目前只有cuda9.0可以匹配tensorflow1.8和1.9，cuda9.1版本太高</h1><p>安装：pip –default-timeout=100 install -U tensorflow<strong><strong>*****</strong></strong></p><p>如果没有pip执行:</p><p>apt-get install python-pip</p><p>验证：</p><p>1.python </p><p>2.import tensorflow </p><p>3.import tensorflow as if </p><p>4.a = tf.constant(’hello world’)      with tf.Session () as sess:     两个空格–print（sess.run(a)） </p><p>Ubuntu18.04验证：</p><p>import tensorflow as tf</p><p>hello =tf.constant(‘hello,world’)——创建常量</p><p>sess =tf.Session()——创建会话</p><p>result =sess.run(hello)——执行</p><p>sess.close()——关闭会话</p><p>print(result)——输出</p><h1 id="十-安装VASP"><a href="#十-安装VASP" class="headerlink" title="十.安装VASP"></a><strong>十.安装VASP</strong></h1><p>详见vsap篇</p><h1 id="十一-安装torch"><a href="#十一-安装torch" class="headerlink" title="十一.安装torch"></a><strong>十一.安装torch</strong></h1><p>pip –default-timeout=100 install torch torchvision</p><p>或：pip3 install  torch torchvision</p><p>如果局限于网速则可以通whl文件离线安装</p><p>验证:</p><p>ipython </p><p>import torch</p><p>或：import pytorch</p><p>import torchvision</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="it" scheme="https://jiangxingye.github.io/categories/it/"/>
    
      <category term="server" scheme="https://jiangxingye.github.io/categories/it/server/"/>
    
    
      <category term="nvidia" scheme="https://jiangxingye.github.io/tags/nvidia/"/>
    
  </entry>
  
  <entry>
    <title>what is the NVMe</title>
    <link href="https://jiangxingye.github.io/2019/09/06/what%20is%20the%20NVMe/"/>
    <id>https://jiangxingye.github.io/2019/09/06/what is the NVMe/</id>
    <published>2019-09-06T01:59:19.000Z</published>
    <updated>2019-09-06T02:12:40.138Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="NVMe-is-what"><a href="#NVMe-is-what" class="headerlink" title="NVMe is what?"></a>NVMe is what?</h1><h2 id="先来看一下Wikipredia的解释。"><a href="#先来看一下Wikipredia的解释。" class="headerlink" title="先来看一下Wikipredia的解释。"></a>先来看一下Wikipredia的解释。</h2><p>wikipedia是这样婶儿说滴。</p><p><strong>NVM Express</strong>（<strong>NVMe</strong>），或称<strong>非易失性内存主机控制器接口规范</strong>（英语：<strong>N</strong>on-<strong>V</strong>olatile <strong>M</strong>emory <strong>H</strong>ost <strong>C</strong>ontroller <strong>I</strong>nterface <strong>S</strong>pecification，缩写：<strong>NVMHCIS</strong>），是一个逻辑设备接口<a href="https://zh.wikipedia.org/wiki/标准" target="_blank" rel="noopener">规范</a>。它是与<a href="https://zh.wikipedia.org/wiki/AHCI" target="_blank" rel="noopener">AHCI</a>类似的、基于设备逻辑接口的<a href="https://zh.wikipedia.org/wiki/匯流排" target="_blank" rel="noopener">总线</a>传输协议规范（相当于通讯协议中的<a href="https://zh.wikipedia.org/wiki/应用层" target="_blank" rel="noopener">应用层</a>），用于访问通过<a href="https://zh.wikipedia.org/wiki/PCI_Express" target="_blank" rel="noopener">PCI Express</a>（PCIe）总线附加的<a href="https://zh.wikipedia.org/wiki/非揮發性記憶體" target="_blank" rel="noopener">非易失性存储器</a>介质（例如采用<a href="https://zh.wikipedia.org/wiki/快閃記憶體" target="_blank" rel="noopener">闪存</a>的<a href="https://zh.wikipedia.org/wiki/固态硬盘" target="_blank" rel="noopener">固态硬盘驱动器</a>），虽然理论上不一定要求PCIe总线协议。</p><p>NVM代表非易失性存储器（non-volatile memory）的<a href="https://zh.wikipedia.org/wiki/首字母縮略字" target="_blank" rel="noopener">首字母缩略字</a>，这是固态硬盘（SSD）的常见的闪存形式。此规范主要是为基于闪存的存储设备提供一个低延时、内部并发化的原生界面规范，也为现代<a href="https://zh.wikipedia.org/wiki/CPU" target="_blank" rel="noopener">CPU</a>、计算机平台及相关应用提供原生存储并发化的支持<a href="https://zh.wikipedia.org/wiki/NVM_Express#cite_note-1" target="_blank" rel="noopener">[1]</a>，令主机硬件和软件可以充分利用固态存储设备的并行化存储能力。相比此前<a href="https://zh.wikipedia.org/wiki/硬碟機" target="_blank" rel="noopener">机械硬盘驱动器</a>（HDD）时代的<a href="https://zh.wikipedia.org/wiki/AHCI" target="_blank" rel="noopener">AHCI</a>，NVMe/NVMHCI降低了<a href="https://zh.wikipedia.org/wiki/I/O" target="_blank" rel="noopener">I/O</a>操作等待时间、提升同一时间内的操作数、更大容量的操作队列等。</p><p>依托于PCIe总线，NVMe设备可适用于各种支持PCIe总线的物理插槽上，包括标准尺寸的PCIe<a href="https://zh.wikipedia.org/w/index.php?title=Expansion_card&action=edit&redlink=1" target="_blank" rel="noopener">扩展卡</a>（一般是4个PCIe通道）<a href="https://zh.wikipedia.org/wiki/NVM_Express#cite_note-2" target="_blank" rel="noopener">[2]</a>、采用<a href="https://zh.wikipedia.org/wiki/U.2" target="_blank" rel="noopener">U.2</a>物理连接界面（SFF-8639）的2.5英寸/3.5英寸标准尺寸固态硬盘驱动器、<a href="https://zh.wikipedia.org/wiki/NVM_Express#cite_note-3" target="_blank" rel="noopener">[3]</a><a href="https://zh.wikipedia.org/wiki/NVM_Express#cite_note-4" target="_blank" rel="noopener">[4]</a><a href="https://zh.wikipedia.org/wiki/SATA_Express" target="_blank" rel="noopener">SATA Express</a>总线（兼容于PCIe）的设备、<a href="https://zh.wikipedia.org/wiki/M.2" target="_blank" rel="noopener">M.2</a>规格扩展卡等。<a href="https://zh.wikipedia.org/wiki/NVM_Express#cite_note-ahci-nvme-5" target="_blank" rel="noopener">[5]</a></p><p>此规范由“Non-Volatile Memory Host Controller Interface Working Group”（非易失性存储器主机控制器界面工作组）负责管理。</p><h2 id="SATA-SAS-PCIe-都是总线规范-或者叫电气接口"><a href="#SATA-SAS-PCIe-都是总线规范-或者叫电气接口" class="headerlink" title="SATA, SAS, PCIe 都是总线规范, 或者叫电气接口"></a>SATA, SAS, PCIe 都是总线规范, 或者叫电气接口</h2><h2 id="SCSI-NVMe-是存储协议"><a href="#SCSI-NVMe-是存储协议" class="headerlink" title="SCSI, NVMe 是存储协议"></a>SCSI, NVMe 是存储协议</h2><h2 id="NAND-3D-Xpoint-是介质"><a href="#NAND-3D-Xpoint-是介质" class="headerlink" title="NAND, 3D-Xpoint 是介质"></a>NAND, 3D-Xpoint 是介质</h2><p>我们用的比较多的是SATA SSD, PCIe SSD, NVMe SSD, Optane</p><p>常用的SATA SSD 对应的存储命令协议是SCSI, PCIe SSD 对应的存储命令协议一般是NVMe.</p><p>所以我们常说的 SATA SSD 指的是 NAND SATA/SAS SCSI SSD. PCIe SSD 指的是 NAND PCIe NVMe SSD, NVMe SSD 指的也是 NAND PCIe NVMe SSD. Optane(Intel 产品) 指的是 3D-Xpoint PCIe NVMe SSD</p><p>不管是用户态还是内核态, 都需要有对应的存储协议的支持, 所以对应的内核上都要有对应driver, 比如 SCSI 就是 isci, NVMe 就是nvme 这个驱动, 这个驱动做的事情就是封装对应格式的命令包, 传输给SSD上, SCSI 就封装成isci IO命令包, NVMe封装成 NVMe IO命令包.</p><p>NVMe 一般会有用户态的驱动, spdk 里面就包含. NVMe 使用内核态也可以把硬件跑满, 但是使用SPDK 的话, 因为使用poll 和 SPDK 的大页机制, 可以让负载比较低的时候 IO 延迟更短</p><p>所以我们一般常说的PCIe SSD, 一般就是NVMe SSD</p><p>NVMe SSD的读大概50us, 写大概可以达到10+us. 因为NVMe内部有ram, 这个写入时间是写到NVMe内部ram 的时间, NVMe自带掉电保护, 所以可以认为写入到内部的ram 就落盘了. 这个ram 的大小是具体根据不同厂商不一样</p><p>目前更快的是3Dxpoint 介质的optane/AEP</p><p>这两个 optane/AEP 都是intel 的产品. optane也是基于PCIe 的NVMe SSD, AEP 走的是内存设备总线, 所以是内存总线的 NVMe SSD。</p><h2 id="使用NVMe有啥优势，可以参考超能网的这篇文章。"><a href="#使用NVMe有啥优势，可以参考超能网的这篇文章。" class="headerlink" title="使用NVMe有啥优势，可以参考超能网的这篇文章。"></a>使用NVMe有啥优势，可以参考超能网的这篇文章。</h2><p><a href="https://www.expreview.com/42142.html" target="_blank" rel="noopener">NVMe到底是什么？用它的SSD有啥优势？</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="it" scheme="https://jiangxingye.github.io/categories/it/"/>
    
      <category term="server" scheme="https://jiangxingye.github.io/categories/it/server/"/>
    
    
      <category term="NVMe" scheme="https://jiangxingye.github.io/tags/NVMe/"/>
    
  </entry>
  
  <entry>
    <title>what is the Hbass</title>
    <link href="https://jiangxingye.github.io/2019/09/04/what%20is%20the%20Hbass/"/>
    <id>https://jiangxingye.github.io/2019/09/04/what is the Hbass/</id>
    <published>2019-09-04T01:08:48.000Z</published>
    <updated>2019-09-04T10:27:53.896Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Hbase-简介"><a href="#Hbase-简介" class="headerlink" title="Hbase 简介"></a>Hbase 简介</h1><h2 id="Hbase概述"><a href="#Hbase概述" class="headerlink" title="Hbase概述"></a>Hbase概述</h2><p>​     Hbase是一个分布式开源数据库，基于Hadoop分布式文件系统，模仿并提供了基于Google文件系统的Bigtable数据库的所有功能。其目标是处理非常庞大的表，可以用普通的计算机处理超过10亿行数据，并且有数百万列元素组成的数据表。Hbase可以直接使用本地文件系统或者Hadoop作为数据存储方式，不过为了提高数据可靠性和系统的健壮性，发挥Hbase处理大数据量等功能，需要使用Hadoop作为文件系统。</p><p>Google BigTable论文中BigTable的定义：Bigtable是一个疏松的分布式的持久的多维排序的map,这个map被行键,列键,和时间戳索引.每一个值都是无解释数组.(A Bigtable is a sparse, distributed, persistent multidimensional sorted map. The map is indexed by a row key, column key, and a timestamp; each value in the map is an uninterpreted array of bytes.)</p><h2 id><a href="#" class="headerlink" title></a></h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="it" scheme="https://jiangxingye.github.io/categories/it/"/>
    
      <category term="hadoop" scheme="https://jiangxingye.github.io/categories/it/hadoop/"/>
    
    
      <category term="hbass" scheme="https://jiangxingye.github.io/tags/hbass/"/>
    
  </entry>
  
  <entry>
    <title>Write a letter to parents</title>
    <link href="https://jiangxingye.github.io/2019/09/02/Write%20a%20letter%20to%20parents/"/>
    <id>https://jiangxingye.github.io/2019/09/02/Write a letter to parents/</id>
    <published>2019-09-02T12:41:12.000Z</published>
    <updated>2019-09-02T13:10:50.261Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>思明区 观音山音乐学校 课后延时服务工作致家长一封信</p><p>家长您好：</p><p>为认真贯彻落实《思明区关于推进小学、幼儿园课后延时服务工作实施方案（试行）》的要求，认真做好我校课后延时服务工作，现将相关情况告知如下：</p><p>课后延时服务工作，是为解决部分小学生家长难以按时接孩子的问题，为正常放学后按时离校有困难（如父母双职工且无其他家人照看等）的小学生提供的延时照顾服务。</p><p>​    1.服务对象。在家长和孩子都自愿参与情况下，经家长（监护人）提出正式申请并获学校审核通过的，下午正常放学后有延时服务需要的学生。</p><p>2.服务内容。以学生自主阅读、完成作业为主。学校安排专人照管学生自行复习、作业、预习和课外阅读等，严格遵守义务教育学校办学行为规范，严禁借机组织开展学科性集中教学，严禁以导优辅差等名义组织或变相组织集体补课。</p><p>3.服务时段。</p><p>（1）本学期课后延时服务从2019年9月9日至2020年1月16日。</p><p>（2）课后延时服务从下午放学后开始，具体时段如下：</p><p>a.课后延时服务结束时间原则上为18:00；</p><p>b.周三为校教职工大会，所以不进行课后延时服务。</p><p><strong>备注：家长应在服务时段结束后，根据学校规定在校门口有序排队接孩子离校。如本时段接孩子离校确有困难，请慎重申请课后延时服务。</strong></p><p>4.制度保障。管理教师将教育敦促学生严格遵守在校的规章制度并做好看管记录，出现紧急情况时及时救助并通知学生监护人，确保学生安全。<strong>对个别不遵守纪律且教育劝阻无效者将约谈学生家长，约谈次数达到三次以上的，以及无故缺席或无特殊情况请假者一个月内三次以上的，学校将暂停为该学生家长提供课后延时服务。</strong></p><p>5.收费标准。每生每月50元，按学期收取、按学期结算，每学期按4个月计算。</p><p>6.如遇特殊情况，学生未能参加当天的课后延时服务，家长需要提前向班主任老师请假。</p><p>7.请您仔细阅读以上条款，如您的孩子正常放学后按时离校确有困难，学生监护人根据学校通知要求填写《思明区观音山音乐学校学生课后延时服务申请表》，向学校提交课后延时服务的书面申请，经学校审核同意后，方可参加课后延时服务。</p><p>​              厦门市思明区观音山音乐学校                                                     日  期： 2019年 9月 2 日      </p><p>………………………………………………………………………………………………………<br>学生：              年     班<br>    本人已收到学校发放的《思明区观音山音乐学校课后延时服务工作致家长一封信》，并已仔细阅读所有条款。<br>                                                 监护人签名：<br>联系电话：<br>                                                 日  期：      年    月    日 </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="edu" scheme="https://jiangxingye.github.io/categories/edu/"/>
    
    
      <category term="Write a letter to parents" scheme="https://jiangxingye.github.io/tags/Write-a-letter-to-parents/"/>
    
  </entry>
  
  <entry>
    <title>server support OS list</title>
    <link href="https://jiangxingye.github.io/2019/09/02/server%20support%20OS%20list/"/>
    <id>https://jiangxingye.github.io/2019/09/02/server support OS list/</id>
    <published>2019-09-02T12:20:22.000Z</published>
    <updated>2019-09-03T06:46:40.254Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><table><thead><tr><th><strong>PM</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><strong>邓克武</strong></td><td><strong>单路C系列产品（PR1280C/2280C/6280C/1285C/2285C/1280C4/1285C4）桌面级系统不支持WIN7，支持WIN10,企业级系统最低支持Windows 2012系统，不兼容Windows 2008版本。</strong>  <strong>图站C系列（PT6610C/PR4610C）/P系列(6620P)/W系列(6630W)系列不支持WIN7，只支持WIN10，不支持Windows服务器级操作系统</strong></td></tr><tr><td><strong>曾柳雄</strong></td><td><strong>双路3/5/7系列（PRX510P/PRX710P/PR2012P/PR2715P/PR2750P/PR6510P）桌面级系统不支持WIN7，支持WIN10,企业级系统最低支持Windows 2012系统，不兼容Windows 2008版本。</strong></td></tr><tr><td><strong>李世伟</strong></td><td><strong>AI**</strong>系列（PR2906P/2908P/4904P/4908P/4910P/4920P/1904PV/4908PV）桌面级不支持WIN7，支持WIN10,上多张显卡不支持Windows Server系列系统**</td></tr><tr><td><strong>李海鸥</strong></td><td><strong>PLSphere**</strong>虚拟化软件当前版本暂不支持vGPU，但可以支持直通模式使用，后续版本会升级支持vGPU特性**</td></tr><tr><td><strong>刘磊</strong></td><td><strong>双路3/5/7系列（PR4024P/PR4036P/PR2720TP/PR2725TP/PR2740TP/PR2745TP/PR4740TP/PR4785TP）企业级系统最低支持Windows 2012系统，不兼容Windows 2008版本。</strong></td></tr><tr><td><strong>邵武</strong></td><td><strong>四路Purely 系列（PR2865P）桌面级系统不支持WIN7，支持WIN10；企业级系统最低支持Windows 2012系统，不兼容Windows 2008版本。</strong></td></tr><tr><td><strong>符芳裕</strong></td><td><strong>工控机系列（NAS-200H/918H/922H/941H/RNB-1402S），企业级系统最低支持Windows 2008系统，桌面系统支持Win7，Win10；（IPC-909C）,企业级系统最低支持Windows 2012系统，桌面系统只支持Win10/64位；网安机器（903B/916B/918S/928S/915S/925S/926G）,企业级系统最低支持Windows 2008系统，桌面系统支持Win7，Win10。</strong></td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="it" scheme="https://jiangxingye.github.io/categories/it/"/>
    
      <category term="server" scheme="https://jiangxingye.github.io/categories/it/server/"/>
    
    
      <category term="Compatibility list" scheme="https://jiangxingye.github.io/tags/Compatibility-list/"/>
    
  </entry>
  
  <entry>
    <title>关闭服务器CPU节能模式</title>
    <link href="https://jiangxingye.github.io/2019/08/16/%E5%85%B3%E9%97%AD%E6%9C%8D%E5%8A%A1%E5%99%A8CPU%E8%8A%82%E8%83%BD%E6%A8%A1%E5%BC%8F/"/>
    <id>https://jiangxingye.github.io/2019/08/16/关闭服务器CPU节能模式/</id>
    <published>2019-08-16T09:58:37.000Z</published>
    <updated>2019-09-11T10:18:05.998Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p><strong>OS系统总关闭P-state模式</strong></p></blockquote><p>CentOS7.x OS中使用了 Intel<br>P-state ，导致机器BIOS关闭节电设置后，处理器的频率依旧处于频繁跳动状态。通过grub禁用<br>Intel P-state解决OS控制处理器频率问题。操作如下：</p><p>使用root账号进入系统打开终端，两种方式，</p><p>第一种：右键 –&gt; Open in Terminal</p><p><img src="/2019/08/16/关闭服务器CPU节能模式/57a36bd3fe871535772594e357e28704.png" alt></p><p>第二种，左上角Applications –&gt; Utilities -&gt; Terminal</p><p><img src="/2019/08/16/关闭服务器CPU节能模式/9511a917506a6dfb5c22f0e5350b1da1.png" alt></p><p>（蓝色字体部分为需要执行的命令）</p><p>在命令行执行lscpu |grep “Hz”，<br>查看CPU是否处于额定主频（红色框中数值是否相等或非常相近，2.10GHz=2100MHz，图中明显不相等），然后执行下列命令：</p><p><img src="/2019/08/16/关闭服务器CPU节能模式/2a813e4dc8d1dede7d408438c47c8260.png" alt></p><ol><li>将更改脚本放到/tmp/目录下。在终端执行sh change_grub.sh</li><li>如果成功，会自动重启，如果失败，会报错”更改失敗，需要手動進行更改”，请联系运维人员</li></ol><p><strong>主板BIOS中设置关闭节能模式</strong></p><p>BIOS关闭节能，方法如下：</p><p>在上一步执行reboot之后会进行重启操作，过程中进入bios系统后 (按Delete键进入)</p><ol><li>CPU configuration Advanced Power Managerment Configuretion</li></ol><p><img src="/2019/08/16/关闭服务器CPU节能模式/6ffb5cf18e02252d2a9134b6a884ae07.png" alt></p><ol start="2"><li>在Power Technology 中选择Custom &amp;&amp; 返回</li></ol><p><img src="/2019/08/16/关闭服务器CPU节能模式/02bb1d016ef0a65ba5260b74c1fcaa0a.png" alt></p><p>3．CPU P state Cotrol -&gt; Disable &amp;&amp; 返回</p><p><img src="/2019/08/16/关闭服务器CPU节能模式/275882948d9b8fc3c23755ad63bfdc7f.png" alt></p><p><img src="/2019/08/16/关闭服务器CPU节能模式/b2b029be99ecb9e650e8e56a10ec6576.png" alt></p><p>4.CPU Cstat Cotrol -&gt; Package C State Limit：C0/C1 state &amp;&amp; 返回</p><p><img src="/2019/08/16/关闭服务器CPU节能模式/95c9b084f7e2fc451407699b7975986b.png" alt></p><p><img src="/2019/08/16/关闭服务器CPU节能模式/b4e8d2e61424419ad2422828dfc01ae9.png" alt></p><p>5.关闭QPI 总线的节能: advanced –&gt; Chipset Configuration -&gt; North Bridge -&gt;<br>QPI Configuration -&gt; QPI General Configuretion —&gt; LINK L0p /L1<br>enable更改为disable 。</p><p><img src="/2019/08/16/关闭服务器CPU节能模式/08aae0c6bb3ac4d4f05a5c0546dd9d7d.png" alt></p><ol start="6"><li>F4 保存退出执行重启</li></ol><p>7、重启完成以后输入账户密码进入系统，打开终端，在命令行执行 lscpu |grep<br>“Hz”查看CPU是否处于额定主频（下图中共色框中两个数值是否相等或非常相近，2.10GHz=2100MHz），如是说明修改成功。</p><p><img src="/2019/08/16/关闭服务器CPU节能模式/6ca684228eb8f4c9cef650d33a2be84a.png" alt></p><p>change_grub.sh 脚本如下</p><pre><code>#!/bin/shcmd=&quot;intel_pstate=disable intel_idle.max_cstate=0 processor.max_cstate=1 idle=poll quiet&quot;check=$(cat /etc/default/grub |grep &quot;intel_pstate=disable intel_idle.max_cstate=0 processor.max_cstate=1 idle=poll&quot; | wc -l ) if [ $check -eq 0 ]    then         sed -i &quot;/GRUB_CMDLINE_LINUX/ s/quiet/$cmd/g&quot; /etc/default/grub    else        printf &quot;the file has been edited at a earlier time&quot;        exit 0fiif [ $? -ne 0 ]then    printf &quot;faild,please change it by edit the file&quot;    exit 1figrub2-mkconfig -o /boot/grub2/grub.cfg &amp;&amp; reboot</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="it" scheme="https://jiangxingye.github.io/categories/it/"/>
    
      <category term="server" scheme="https://jiangxingye.github.io/categories/it/server/"/>
    
    
      <category term="关闭服务器CPU节能模式" scheme="https://jiangxingye.github.io/tags/%E5%85%B3%E9%97%AD%E6%9C%8D%E5%8A%A1%E5%99%A8CPU%E8%8A%82%E8%83%BD%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>meiyatest</title>
    <link href="https://jiangxingye.github.io/2019/08/15/meiyatest/"/>
    <id>https://jiangxingye.github.io/2019/08/15/meiyatest/</id>
    <published>2019-08-15T07:25:06.000Z</published>
    <updated>2019-09-03T13:39:06.403Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>美亚CH服务器性能基准测试</p><h1 id="硬件配置一览表"><a href="#硬件配置一览表" class="headerlink" title="硬件配置一览表"></a>硬件配置一览表</h1><table><thead><tr><th><strong>型号</strong></th><th><strong>内部名称</strong></th><th><strong>技术规格</strong></th></tr></thead><tbody><tr><td>刀片机</td><td>还原（配套智能网卡）-低配</td><td>高密多节点服务器，每U≥2节点，总高度≤4U/每节点配置:2颗英特尔至强银牌4110 CPU（2.1GHz，8核）/128G DDR4内存/1*600G 15K SAS希捷硬盘/<strong>按厂商需求配备raid（有些品牌不配raid没法识别硬盘）</strong>/至少配备2个千兆网口，1个独立MGMT带外管理口（支持远程KVM功能)/预留至少1个半高半长pcie3.0*8网卡的插槽（长167mm，高68mm,厚16mm）/支持CentOS7.3，同时支持更高版本/带导轨/机箱冗余电源/备注功耗</td></tr><tr><td></td><td>还原（配套智能网卡）-中配</td><td>高密多节点服务器，每U≥2节点，总高度≤4U/每节点配置：2颗英特尔至强银牌4114 CPU（2.2GHz，10核）/256G DDR4内存/1*600G 15K SAS希捷硬盘/<strong>按厂商需求配备raid（有些品牌不配raid没法识别硬盘）</strong>/至少配备2个千兆网口，1个独立MGMT带外管理口（支持远程KVM功能/预留至少1个半高半长pcie3.0*8网卡的插槽（长167mm，高68mm,厚16mm）/支持CentOS7.3，同时支持更高版本/带导轨/机箱冗余电源/备注功耗</td></tr><tr><td></td><td>还原（配套智能网卡）-高配</td><td>高密多节点服务器，每U≥2节点，总高度≤4U/每节点配置为：2颗英特尔至强金牌6126 CPU（2.6GHz，12核）/512G DDR4内存/1*600G 15K SAS希捷硬盘/<strong>按厂商需求配备raid（有些品牌不配raid没法识别硬盘）</strong>/至少配备2个千兆网口，1个独立MGMT带外管理口（支持远程KVM功能）/预留至少1个半高半长pcie3.0*8网卡的插槽（长167mm，高68mm,厚16mm）/支持CentOS7.3，同时支持更高版本/带导轨/机箱冗余电源/备注功耗</td></tr><tr><td>索引服务器</td><td>索引</td><td>2U服务器/2颗英特尔至强银牌4110 CPU（2.1GHz，8核）/64G DDR4/8*900G SAS 10000rpm/ Raid0、1、5、6（1G缓存带超级电容）/双万兆和双千兆网口，不配万兆光模块（要求都是Intel的网卡，并且千兆支持支持IGB驱动，igb-3.2.10、igb-3.4.7、igb-5.1.2 这些版本都可以，万兆支持IXGBE驱动）、1个独立带外管理端口（支持远程KVM）/支持CentOS7.3，同时支持更高版本/带导轨，单电源/</td></tr><tr><td>存储服务器</td><td>存储</td><td>2U服务器/2颗英特尔至强银牌4110 CPU（2.1GHz，8核）/128G DDR4/12*8T SATA 7200RPM/Raid0,1,5,6（1G或以上缓存，带超级电容，支持12个硬盘做1组Raid6）/每服务器双万兆和双千兆网口，不配万兆光模块（要求都是Intel的网卡，并且千兆支持支持IGB驱动，igb-3.2.10、igb-3.4.7、igb-5.1.2 这些版本都可以，万兆支持IXGBE驱动），1个独立MGMT带外管理口（支持远程KVM功能）/支持CentOS7.3及以上版本/带导轨，单电源/要求使用希捷企业级热插拔服务器硬盘/</td></tr></tbody></table><h1 id="系统安装要求"><a href="#系统安装要求" class="headerlink" title="系统安装要求"></a>系统安装要求</h1><p>出厂预安装:做好raid5、划分VD、安装Centos 7.3<br>64位、安装图形化界面等操作。（避免现场安装失败问题）</p><p>1、刀片机 ：<br>直接安装系统，无需做raid，按厂商需求配备raid（有些品牌不配raid没法识别硬盘）；</p><p>2、SOLR : raid5，划分2个VD （VD0 ：600G VD1 ：剩余空间 ，挂载为/data）</p><p>3、HBase : raid5，划分2个VD （VD0 ：600G VD1 ：16T ，挂载为/data<br>,其余空间不用挂载）</p><h1 id="测试环境准备"><a href="#测试环境准备" class="headerlink" title="测试环境准备"></a>测试环境准备</h1><p><strong>准备工作</strong></p><p>以下要求适用于sorl、存储的CentOS V7.3及以上版本的服务器。</p><p><strong>操作系统参数</strong></p><p>vi /etc/security/limits.conf</p><p>* hard nofile 1000000</p><p>* soft nofile 1000000</p><p>* hard nproc 409600</p><p>* soft nproc 409600</p><p>vi /etc/security/limits.d/20-nproc.conf</p><p>* soft nproc 409600</p><p>echo 0 &gt; /proc/sys/vm/swappiness;</p><p>echo vm.swappiness=0 &gt;&gt; /etc/sysctl.conf</p><p>设置linux内核参数：</p><p>vi /etc/sysctl.conf</p><p>net.core.somaxconn = 8192</p><p>net.ipv4.tcp_max_syn_backlog = 8192</p><p>net.ipv4.tcp_synack_retries = 2</p><p>net.ipv4.tcp_syn_retries = 2</p><p>net.ipv4.tcp_timestamps = 0</p><p>net.ipv4.tcp_window_scaling = 1</p><p>net.core.rmem_max = 16777216</p><p>net.core.wmem_max = 16777216</p><p>net.ipv4.tcp_rmem = 4096 87380 16777216</p><p>net.ipv4.tcp_wmem = 4096 87380 16777216</p><p>kernel.pid_max = 200000</p><p>vm.max_map_count = 400000</p><p>并执行：</p><p>sysctl -p</p><p><strong>禁用SELINUX { 或 /etc/sysconfig/selinux disabled }</strong></p><p>vi /etc/selinux/config</p><p>SELINUX=disabled</p><p>并执行：</p><p>setenforce 0</p><p><strong>禁用iptables</strong></p><p>systemctl stop firewalld #关闭防火墙</p><p>systemctl disable firewalld #禁止开机启动</p><p><strong>HBase: gcc-c++安装</strong></p><p>CentOS7.3 gcc-c++ 将依赖的包放在ee文件夹上传到/opt目录或者从系统盘中安装</p><p>cd /opt/ee</p><p>执行如下操作：</p><p>rpm -ivh glibc-common-2.17-157.el7.x86_64.rpm</p><p>rpm -ivh kernel-headers-3.10.0-514.el7.x86_64.rpm</p><p>rpm -ivh libgcc-4.8.5-11.el7.x86_64.rpm</p><p>rpm -ivh libgcc-4.8.5-11.el7.i686.rpm</p><p>rpm -ivh glibc-2.17-157.el7.x86_64.rpm</p><p>rpm -ivh mpfr-3.1.1-4.el7.x86_64.rpm</p><p>rpm -ivh libgomp-4.8.5-11.el7.x86_64.rpm</p><p>rpm -ivh nscd-2.17-157.el7.x86_64.rpm</p><p>rpm -ivh glibc-headers-2.17-157.el7.x86_64.rpm</p><p>rpm -ivh glibc-devel-2.17-157.el7.x86_64.rpm</p><p>rpm -ivh libstdc++-4.8.5-11.el7.x86_64.rpm</p><p>rpm -ivh libstdc++-devel-4.8.5-11.el7.x86_64.rpm</p><p>rpm -ivh libmpc-1.0.1-3.el7.x86_64.rpm</p><p>rpm -ivh cpp-4.8.5-11.el7.x86_64.rpm</p><p>rpm -ivh gcc-4.8.5-11.el7.x86_64.rpm</p><p>rpm -ivh gcc-c++-4.8.5-11.el7.x86_64.rpm</p><p>[@more@] gcc -v （查看是否安装成功）</p><p>[root@localhost ee]# gcc -v</p><p>Using built-in specs.</p><p>COLLECT_GCC=gcc</p><p>COLLECT_LTO_WRAPPER=/usr/libexec/gcc/x86_64-redhat-linux/4.8.5/lto-wrapper</p><p>Target: x86_64-redhat-linux</p><p>Configured with: ../configure –prefix=/usr –mandir=/usr/share/man<br>–infodir=/usr/share/info –with-bugurl=<a href="http://bugzilla.redhat.com/bugzilla" target="_blank" rel="noopener">http://bugzilla.redhat.com/bugzilla</a><br>–enable-bootstrap –enable-shared –enable-threads=posix<br>–enable-checking=release –with-system-zlib –enable-__cxa_atexit<br>–disable-libunwind-exceptions –enable-gnu-unique-object<br>–enable-linker-build-id –with-linker-hash-style=gnu<br>–enable-languages=c,c++,objc,obj-c++,java,fortran,ada,go,lto –enable-plugin<br>–enable-initfini-array –disable-libgcj<br>–with-isl=/builddir/build/BUILD/gcc-4.8.5-20150702/obj-x86_64-redhat-linux/isl-install<br>–with-cloog=/builddir/build/BUILD/gcc-4.8.5-20150702/obj-x86_64-redhat-linux/cloog-install<br>–enable-gnu-indirect-function –with-tune=generic –with-arch_32=x86-64<br>–build=x86_64-redhat-linux</p><p>Thread model: posix</p><p>gcc version 4.8.5 20150623 (Red Hat 4.8.5-11) (GCC) (说明安装成功)</p><p><strong>JDK安装</strong></p><p>cd /usr/local</p><p>将jdk1.7.0_25.tar.gz放在/usr/local解压.</p><p>ln -s /usr/local/jdk1.7.0_25/ /usr/local/java7</p><p>vi /etc/profile</p><p>添加：</p><p>export JAVA_HOME=/usr/local/java7</p><p>export PATH=$JAVA_HOME/bin:$PATH</p><p>export HADOOP_HOME=/usr/local/hadoop</p><p>export PATH=$HADOOP_HOME/bin:$PATH</p><p>export HBASE_HOME=/usr/local/hbase</p><p>export PATH=$HBASE_HOME/bin:$PATH</p><p>并执行：</p><p>source /etc/profile</p><h1 id="FIO测试"><a href="#FIO测试" class="headerlink" title="FIO测试"></a>FIO测试</h1><h2 id="1、fio安装"><a href="#1、fio安装" class="headerlink" title="1、fio安装"></a>1、fio安装</h2><p>fio-2.1.10.tar.gz解压至/usr/local/</p><p>cd /usr/local</p><p>tar zxvf fio-2.1.10.tar.gz</p><p>cd fio-2.0.7<br>make<br>make install</p><p>fio测试</p><h2 id="2、还原机FIO"><a href="#2、还原机FIO" class="headerlink" title="2、还原机FIO"></a>2、还原机FIO</h2><p>随机写50MB ，bs 2k</p><p>fio -filename=/dev/sda -direct=1 -iodepth 8 -thread -rw=randwrite<br>-ioengine=psync -bs=2k -size=50MB -numjobs=30 -runtime=300 -group_reporting<br>-name=mytest</p><p>随机写1G ，bs 4k</p><p>fio -filename=/dev/sda -direct=1 -iodepth 8 -thread -rw=randwrite<br>-ioengine=psync -bs=4k -size=1G -numjobs=30 -runtime=300 -group_reporting<br>-name=mytest</p><p>顺序读50M ，bs 2k</p><p>fio -filename=/dev/sda -direct=1 -iodepth 8 -thread -rw=read -ioengine=psync<br>-bs=2k -size=50MB -numjobs=30 -runtime=300 -group_reporting -name=mytest</p><p>顺序读1G ，bs 4k</p><p>fio -filename=/dev/sda -direct=1 -iodepth 8 -thread -rw=read -ioengine=psync<br>-bs=4k -size=1G -numjobs=30 -runtime=300 -group_reporting -name=mytest</p><h2 id="3、索引FIO"><a href="#3、索引FIO" class="headerlink" title="3、索引FIO"></a>3、索引FIO</h2><p>顺序写500MB ，bs 512k</p><p>fio -filename=/dev/sdb -direct=1 -iodepth 8 -thread -rw=write -ioengine=psync<br>-bs=512K -size=500MB -numjobs=30 -runtime=300 -group_reporting -name=mytest</p><p>顺序写1G，bs 1MB</p><p>fio -filename=/dev/sdb -direct=1 -iodepth 8 -thread -rw=write -ioengine=psync<br>-bs=1MB -size=1G -numjobs=30 -runtime=300 -group_reporting -name=mytest</p><p>随机读500MB ，bs 512k</p><p>fio -filename=/dev/sdb -direct=1 -iodepth 8 -thread -rw=randread -ioengine=psync<br>-bs=512K -size=500MB -numjobs=30 -runtime=300 -group_reporting -name=mytest</p><p>随机读1G ，bs 1MB</p><p>fio -filename=/dev/sdb -direct=1 -iodepth 8 -thread -rw=randread -ioengine=psync<br>-bs=1MB -size=1G -numjobs=30 -runtime=300 -group_reporting -name=mytest</p><h2 id="4、存储FIO"><a href="#4、存储FIO" class="headerlink" title="4、存储FIO"></a>4、存储FIO</h2><p>顺序写500MB ，bs 512k</p><p>fio -filename=/dev/sdb -direct=1 -iodepth 8 -thread -rw=write -ioengine=psync<br>-bs=512K -size=500MB -numjobs=30 -runtime=300 -group_reporting -name=mytest</p><p>顺序写1G，bs 1MB</p><p>fio -filename=/dev/sdb -direct=1 -iodepth 8 -thread -rw=write -ioengine=psync<br>-bs=1MB -size=1G -numjobs=30 -runtime=300 -group_reporting -name=mytest</p><p>随机读500MB ，bs 512k</p><p>fio -filename=/dev/sdb -direct=1 -iodepth 8 -thread -rw=randread -ioengine=psync<br>-bs=512K -size=500MB -numjobs=30 -runtime=300 -group_reporting -name=mytest</p><p>随机读1G ，bs 1MB</p><p>fio -filename=/dev/sdb -direct=1 -iodepth 8 -thread -rw=randread -ioengine=psync<br>-bs=1MB -size=1G -numjobs=30 -runtime=300 -group_reporting -name=mytest</p><h1 id="索引基准测试"><a href="#索引基准测试" class="headerlink" title="索引基准测试"></a>索引基准测试</h1><h2 id="SOLR安装"><a href="#SOLR安装" class="headerlink" title="SOLR安装"></a>SOLR安装</h2><p>solrs.tar 解压至/usr/local/</p><p>tar xvf solrs.tar</p><p>solrs_data.tar 解压至/data</p><p>tar xvf solrs_data.tar</p><h2 id="将数据解压至-data"><a href="#将数据解压至-data" class="headerlink" title="将数据解压至/data"></a>将数据解压至/data</h2><p>scp ip:/home/benchmark_solr.tar /data</p><p>cd /data</p><p>tar xvf benchmark_solr.tar</p><h2 id="solr基准测试"><a href="#solr基准测试" class="headerlink" title="solr基准测试"></a>solr基准测试</h2><p>启动solr</p><p>killall java;</p><p>/data/benchmark/solrs/yk/bin/startup.sh</p><p>清空系统缓存</p><p>echo 3 &gt; /proc/sys/vm/drop_caches</p><p>验证http://<strong>ip</strong>:8900/solr/yk/select?q=*%3A*&amp;wt=json&amp;indent=true确保访问正常，返回如下结果</p><p><img src="/2019/08/15/meiyatest/3f08f42e7eb2c1942eeed79dd1085cb3.png" alt="wps_clip_image-22344.png"></p><p>登录任意一台服务器（如：172.16.20.159，与solr服务器同一网段），安装perl环境（perl为系统盘对应的版本）</p><p>将benchmark.tar.gz文件解压到/opt目录后执行如下操作：</p><p>cd /opt/benchmark/solr/</p><p>修改benchmark.perl一些参数配置：</p><p>forkCount:并发数 测试并发数为：100</p><p>queryCount:查询次数 测试并发数为：1000</p><p>urlHost：目标主机ip 根据实际SOLR服务器的ip配置</p><p><img src="/2019/08/15/meiyatest/69ac37994a381a720102b2a5db2a68e8.png" alt></p><p>执行benchmark文件：perl benchmark.perl，运行结果：</p><p><img src="/2019/08/15/meiyatest/2449c646329951cf1d16064b6ee872ae.png" alt="wps_clip_image-22442.png"></p><p>Req/s:(每秒请求数)</p><p>Avg:平均耗时</p><p>Median:中间耗时</p><p>95th:95%的查询耗在2.604范围</p><p>99th:99%的查询耗时在5.498范围</p><p>Max：最大耗时</p><h1 id="存储基准测试"><a href="#存储基准测试" class="headerlink" title="存储基准测试"></a>存储基准测试</h1><h2 id="1、主机名配置"><a href="#1、主机名配置" class="headerlink" title="1、主机名配置"></a>1、主机名配置</h2><p>vi /etc/sysconfig/network</p><p><img src="/2019/08/15/meiyatest/45931771e1bb7e555a61ea0ec9db9811.png" alt></p><p>并执行hostname HBase-01</p><h2 id="2、主机名查询静态表配置"><a href="#2、主机名查询静态表配置" class="headerlink" title="2、主机名查询静态表配置"></a>2、主机名查询静态表配置</h2><p><img src="/2019/08/15/meiyatest/2e2abea932820757fd7fbede289d6046.png" alt></p><h2 id="3、snappy安装"><a href="#3、snappy安装" class="headerlink" title="3、snappy安装"></a>3、snappy安装</h2><p>snappy-1.1.2.tar.gz解压至/opt/下</p><p>cd /opt;</p><p>tar zxvf snappy-1.1.2.tar.gz</p><p>cd /snappy-1.1.2</p><p>./configure</p><p>make</p><blockquote><p>make install</p></blockquote><h2 id="4、ssh无密码登陆"><a href="#4、ssh无密码登陆" class="headerlink" title="4、ssh无密码登陆"></a>4、ssh无密码登陆</h2><p>ssh-keygen -t rsa （回车到底）</p><blockquote><p>cat /root/.ssh/id_rsa.pub &gt;&gt; /root/.ssh/authorized_keys</p></blockquote><h2 id="5、hadoop安装"><a href="#5、hadoop安装" class="headerlink" title="5、hadoop安装"></a>5、hadoop安装</h2><blockquote><p>解压hadoop.tar至/usr/local/</p></blockquote><p>tar xvf hadoop.tar</p><p>ln -s /usr/local/hadoop-1.0.3/ /usr/local/hadoop</p><blockquote><p>ln -s /usr/local/hbase-0.94.1/ /usr/local/hbase</p></blockquote><h2 id="6、hadoop启动"><a href="#6、hadoop启动" class="headerlink" title="6、hadoop启动"></a>6、hadoop启动</h2><p>killall -s 9 java</p><p>rm -rf /data/hadoop/</p><p>hadoop namenode -format</p><p>start-all.sh</p><h2 id="7、hadoop验证"><a href="#7、hadoop验证" class="headerlink" title="7、hadoop验证"></a>7、hadoop验证</h2><blockquote><p>查看<a href="http://172.16.20.232:50070/dfshealth.jsp页面，确保访问正常，同时" target="_blank" rel="noopener">http://172.16.20.232:50070/dfshealth.jsp页面，确保访问正常，同时</a> Dead<br>Nodes为0</p></blockquote><blockquote><p>执行jps命令,确保有以下的进程</p></blockquote><p><img src="/2019/08/15/meiyatest/a33a5ef81689966982262057c2f8145d.png" alt="wps_clip_image-24620.png"></p><h2 id="9、HBase基准测试"><a href="#9、HBase基准测试" class="headerlink" title="9、HBase基准测试"></a>9、HBase基准测试</h2><p>测试工具（yscb安装）</p><p>mkdir -p /opt/benchmark/hbase/;</p><p>解压yscb至/opt/benchmark/hbase/</p><p>cd /opt/benchmark/hbase/</p><p>tar zxvf ycsb-0.1.4.tar.gz</p><h2 id="10、HBase启动"><a href="#10、HBase启动" class="headerlink" title="10、HBase启动"></a>10、HBase启动</h2><p>清空系统缓存:</p><p>echo 3 &gt; /proc/sys/vm/drop_caches</p><p>killall -s 9 java</p><p>rm -rf /data/hadoop/</p><p>hadoop namenode -format</p><p>start-dfs.sh</p><p>start-hbase.sh</p><h2 id="11、HBase验证"><a href="#11、HBase验证" class="headerlink" title="11、HBase验证"></a>11、HBase验证</h2><blockquote><p>查看<a href="http://172.16.20.232:60010/master-status页面，确保访问正常，同时没有Dead" target="_blank" rel="noopener">http://172.16.20.232:60010/master-status页面，确保访问正常，同时没有Dead</a><br>Region Servers</p></blockquote><blockquote><p>执行jps命令,确保有以下的进程：</p></blockquote><p><img src="/2019/08/15/meiyatest/3f13831faa7287894df35d582719048f.png" alt="wps_clip_image-26658.png"></p><h2 id="12、HBase基准测试"><a href="#12、HBase基准测试" class="headerlink" title="12、HBase基准测试"></a>12、HBase基准测试</h2><p>创建hbase表</p><p>echo “create ‘usertable’,’f1’,’f2’,’f3’”|hbase shell</p><p>查看表是否已经创建</p><p>echo list|hbase shell</p><p><img src="/2019/08/15/meiyatest/807fc1f42a0e08e3398a48ad6bdd9c2c.png" alt="wps_clip_image-27334.png"></p><p>清空系统缓存:</p><p>echo 3 &gt; /proc/sys/vm/drop_caches</p><p>cd /opt/benchmark/hbase/ycsb-0.1.4/bin;</p><p>执行插入测试，创建100个线程,插入100w条记录：</p><blockquote><p>./ycsb load hbase -P ../workloads/workloada -p threads=100 -p<br>columnfamily=f1 -p recordcount=1000000 -s &gt; load.dat</p></blockquote><p>测试结果存取在load.dat中,查看load.dat有如下结果</p><p>grep -v -E ‘UPDATE|CLEANUP’ load.dat|more</p><p><img src="/2019/08/15/meiyatest/bb56c0029f8f549b4cc984e036524a18.png" alt="wps_clip_image-27170.png"></p><p>Runtime:执行时间(ms)</p><p>Throughput(ops/sec):吞吐量(每秒操作次数)</p><p>Operations：操作总数</p><p>AverageLatency：平均耗时(us)</p><p>MinLatency:最小耗时(us)</p><p>MaxLatency:最大耗时(us)</p><p>95thPercentileLatency(ms):95%的执行时间范围</p><p>99thPercentileLatency(ms):99%的执行时间范围</p><blockquote><p>执行事务操作(95%的读操作 5%的写操作)</p></blockquote><blockquote><p>创建100个线程,操作100w次</p></blockquote><blockquote><p>./ycsb run hbase -P ../workloads/workloadb -threads 100 -p<br>measurementtype=timeseries -p columnfamily=f1 -p operationcount=1000000 -p<br>timeseries.granularity=2000 &gt; transactions.dat</p></blockquote><blockquote><p>测试结果存取在transactions.dat中</p></blockquote><blockquote><p>查看更新操作测试结果</p></blockquote><blockquote><p>grep UPDATE transactions.dat</p></blockquote><blockquote><p>查看读取操作测试结果</p></blockquote><blockquote><p>grep READ transactions.dat</p></blockquote><p><img src="/2019/08/15/meiyatest/8e432a6721779f92712efc517a20e388.png" alt></p><h1 id="NMON监控"><a href="#NMON监控" class="headerlink" title="NMON监控"></a>NMON监控</h1><p>在做SOLR或HBase基准测试时，使用nmon监控服务器的CPU、内存、磁盘资源使用情况</p><h2 id="1、安装nmon"><a href="#1、安装nmon" class="headerlink" title="1、安装nmon"></a>1、安装nmon</h2><blockquote><p>解压nmon至/usr/local/</p></blockquote><blockquote><p>cd /usr/local</p></blockquote><blockquote><p>tar zxvf nmon.tar.gz</p></blockquote><h2 id="2、修改nmon参数"><a href="#2、修改nmon参数" class="headerlink" title="2、修改nmon参数"></a>2、修改nmon参数</h2><blockquote><p>cd nmon</p></blockquote><blockquote><p>vi nmon_start.sh</p></blockquote><blockquote><p>修改频率为10秒一次，监控5000次：</p></blockquote><p><img src="/2019/08/15/meiyatest/55693422c2f187bede43e163626a9a9d.png" alt></p><h2 id="3、运行nmon"><a href="#3、运行nmon" class="headerlink" title="3、运行nmon"></a>3、运行nmon</h2><blockquote><p>做基准测试同时，运行nmon，监控测试时的硬件资源使用情况</p></blockquote><blockquote><p>./nmon_start.sh</p></blockquote><blockquote><p>同一目录下会生成nmon文件</p></blockquote><p><img src="/2019/08/15/meiyatest/8e979ce79ec9cd55ae8dd17c544bc865.png" alt></p><h2 id="4、关掉nmon"><a href="#4、关掉nmon" class="headerlink" title="4、关掉nmon"></a>4、关掉nmon</h2><blockquote><p>基准测试结束时，停掉nmon</p></blockquote><blockquote><p>Killall nmon</p></blockquote><h2 id="5、生成图形化结果"><a href="#5、生成图形化结果" class="headerlink" title="5、生成图形化结果"></a>5、生成图形化结果</h2><blockquote><p>打开nmon analyser v34a.xls，点击Analyse nmon data<br>按键，加载nmon文件，生成图形化结果：</p></blockquote><p><img src="/2019/08/15/meiyatest/594cc99f55d6df5ec031b64b43d0f00b.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="it" scheme="https://jiangxingye.github.io/categories/it/"/>
    
      <category term="server" scheme="https://jiangxingye.github.io/categories/it/server/"/>
    
    
      <category term="美亚测试机" scheme="https://jiangxingye.github.io/tags/%E7%BE%8E%E4%BA%9A%E6%B5%8B%E8%AF%95%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>苏联解体的启示</title>
    <link href="https://jiangxingye.github.io/2019/08/12/%E8%8B%8F%E8%81%94%E8%A7%A3%E4%BD%93%E7%9A%84%E5%90%AF%E7%A4%BA/"/>
    <id>https://jiangxingye.github.io/2019/08/12/苏联解体的启示/</id>
    <published>2019-08-12T11:15:19.000Z</published>
    <updated>2019-09-03T02:59:33.722Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>从1989春至1991年底，短短两年，人类历史上最强大的专政机器——苏联东欧红色帝国土崩瓦解。这是二十世纪最伟大的故事。</p><p>一个皇朝的解体，一般可以概括为：“生于不义，死于耻辱。”</p><p>皇朝倒台前会有几个特点：</p><p>货币急速贬值，老百姓爱做梦。</p><p>美国当年成立特殊金融小组制裁前苏联，导致苏联解体。</p><p>表面强大的前苏联，就这样既无外敌入侵，又没有天灾，自己就玩不下去了，就解体了。</p><p>朝鲜经济短时间内很难稳定，楼市、基建、政府各种债务出清，国有资产私有化，</p><p>区域自治的各地关税统一等等，这些问题牵扯到的利益博弈将是及其复杂，</p><p>没有十几年的争吵很难达成统一，毕竟是各方都有选票，财富无论怎么划分，</p><p>都会有人不满意，这就注定了未来朝鲜金融系统将会长期动荡。</p><p>总之，生活在百姓无知，爱做梦的国家，挺难的，不确定性太大。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="read" scheme="https://jiangxingye.github.io/categories/read/"/>
    
    
      <category term="苏联解体" scheme="https://jiangxingye.github.io/tags/%E8%8B%8F%E8%81%94%E8%A7%A3%E4%BD%93/"/>
    
  </entry>
  
  <entry>
    <title>如何在服务器的BIOS中设置上电自启动</title>
    <link href="https://jiangxingye.github.io/2019/08/12/%E5%A6%82%E4%BD%95%E5%9C%A8%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84BIOS%E4%B8%AD%E8%AE%BE%E7%BD%AE%E4%B8%8A%E7%94%B5%E8%87%AA%E5%90%AF%E5%8A%A8/"/>
    <id>https://jiangxingye.github.io/2019/08/12/如何在服务器的BIOS中设置上电自启动/</id>
    <published>2019-08-12T06:36:33.000Z</published>
    <updated>2019-09-03T01:18:47.131Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong>说明：</strong></p><p>1、为什么要实现这种功能，很多时候在民间都基本用普通PC来做小型服务器，公司的私服等等，而这些普通PC在民用电环境中经常会停电，一停就会导致服务器不能自动来电重启，所以这个功能来点开机是必须的。</p><p>2、普通PC基本都是以下这些配置方式，但不要和服务器主板做比较，服务器主板有专业的配置选项以及专业的来电自动启动设备。</p><p><strong>下面根据不同的BIOS列出相应的设置方法：</strong></p><p><img src="/2019/08/12/如何在服务器的BIOS中设置上电自启动/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20190812142347.png" alt></p><p>1：首先进入BIOS的设置主界面，选择[POWER MANAGEMENT SETUP]，再选择[PWR Lost Resume State]，这一项有三个选择项。</p><p>选择[Keep OFF]项，代表停电后再来电时，电脑不会自动启动。<br>        选择[Turn On]项，代表停电后再来电时，电脑会自动启动。<br>        选择的[Last State]，那么代表停电后再来电时，电脑恢复到停电前电脑的状态。断电前如果电脑是处于开机状态，那么来电后就会自动开机。断电前是处于关机状态，那么来电后电脑不会自动开机。</p><p>2：首先进入Power Management Setup（电源管理设定）→Power Again（再来电状态），此项决定了开机时意外断电之后，电力供应恢复时系统电源的状态。设定值有：<br>Power Off（保持系统处于关机状态）<br>Power On（保持系统处于开机状态）<br>Last State（恢复到系统断电前的状态）进入挂起/睡眠模式，但若按钮被揿下超过4秒，机器关机。<br>若想来电自动开机把上面的这项改成power on就行了！</p><p>3：有的BIOS中[POWER MANAGEMENT SETUP]没有上面说的[PWR Lost Resume State]，可以在[PWRON After PWR-Fail]→[Integrated Peripherals]选项中找到两个选项：ON(打开自动开机)和OFF(关闭自动开机)，设置为OFF即可。<br>不同的主板及BIOS型号相对应的选项会有所不同，但我想应该会差不多，一般都在[POWER MANAGEMENT SETUP]这个选项中可以找到相应的设置选项！  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="it" scheme="https://jiangxingye.github.io/categories/it/"/>
    
      <category term="server" scheme="https://jiangxingye.github.io/categories/it/server/"/>
    
    
      <category term="如何在服务器的BIOS中设置上电自启动" scheme="https://jiangxingye.github.io/tags/%E5%A6%82%E4%BD%95%E5%9C%A8%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84BIOS%E4%B8%AD%E8%AE%BE%E7%BD%AE%E4%B8%8A%E7%94%B5%E8%87%AA%E5%90%AF%E5%8A%A8/"/>
    
  </entry>
  
  <entry>
    <title>raid丢失系统恢复案例</title>
    <link href="https://jiangxingye.github.io/2019/08/12/raid%E4%B8%A2%E5%A4%B1%E7%B3%BB%E7%BB%9F%E6%81%A2%E5%A4%8D%E6%A1%88%E4%BE%8B/"/>
    <id>https://jiangxingye.github.io/2019/08/12/raid丢失系统恢复案例/</id>
    <published>2019-08-12T04:31:04.000Z</published>
    <updated>2019-09-03T01:18:21.817Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="How-to-fix-“No-Bootable-Device”-issue-on-server"><a href="#How-to-fix-“No-Bootable-Device”-issue-on-server" class="headerlink" title="How to fix “No Bootable Device” issue on server?"></a>How to fix “No Bootable Device” issue on server?</h1><p><strong>故障现象：</strong></p><p><img src="/2019/08/12/raid丢失系统恢复案例/353c3787ac700e369a1951dade7f985.jpg" alt="故障图片"></p><p><strong>原因分析：</strong>客户机器有独立的RAID卡，2块物理磁盘做的RAID0，和客户沟通，RAID卡进去状态不正常，不想重新安装系统。因为上面的环境配置很麻烦。</p><p><strong>处理过程：</strong> 重新在RAID卡里做同级别RAID的话，不在raid里做clear操作的话，数据不丢失的话，理论上系统是有办法恢复的，如果数据会消失，那就要重做了。经验证，做同级别RAID系统恢复，数据并未消失。</p><p><strong>问题解决：</strong></p><p><img src="/2019/08/12/raid丢失系统恢复案例/22.png" alt="问题解决"></p><p><strong>建议：</strong> 如果系统上有重要数据的话，还是建议使用RAID1会安全一些。</p><p>如果你忙觉得上述案例帮助了您，给个赞哦，当然也可以打赏杯可乐，我就不用喝酱油兑水了,^_^ </p><p>么么哒！</p><p><strong>服务器购买也可以通过下面的联系方式向我咨询。</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="it" scheme="https://jiangxingye.github.io/categories/it/"/>
    
      <category term="server" scheme="https://jiangxingye.github.io/categories/it/server/"/>
    
    
      <category term="bootable device were deteced." scheme="https://jiangxingye.github.io/tags/bootable-device-were-deteced/"/>
    
  </entry>
  
  <entry>
    <title>shell速查表</title>
    <link href="https://jiangxingye.github.io/2018/09/08/shell-command/"/>
    <id>https://jiangxingye.github.io/2018/09/08/shell-command/</id>
    <published>2018-09-08T03:48:24.000Z</published>
    <updated>2019-09-02T13:02:59.999Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1-变量"><a href="#1-变量" class="headerlink" title="1. 变量"></a>1. 变量</h2><pre><code class="bash">#!/bin/bashmsg=&quot;hello world&quot;echo $msg</code></pre><blockquote><p><strong>变量名的命名须遵循如下规则：</strong></p><ul><li>命名只能使用英文字母，数字和下划线，首个字符不能以数字开头。</li><li>中间不能有空格，可以使用下划线（_）。</li><li>不能使用标点符号。</li><li>不能使用bash里的关键字（可用help命令查看保留关键字）。</li></ul></blockquote><h2 id="2-传参"><a href="#2-传参" class="headerlink" title="2. 传参"></a>2. 传参</h2><pre><code class="bash">#!/bin/bashecho &quot;执行的文件名：$0&quot;;echo &quot;第一个参数为：$1&quot;;echo &quot;第二个参数为：$2&quot;;echo &quot;第三个参数为：$3&quot;;</code></pre><blockquote><p><strong>脚本内获取参数的格式为：</strong><br>$n。n 代表一个数字，1 为执行脚本的第一个参数，2 为执行脚本的第二个参数，以此类推……<br><strong>另外，还有几个特殊字符用来处理参数：</strong></p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td><code>$#</code></td><td>传递到脚本的参数个数</td></tr><tr><td><code>$*</code></td><td>以一个单字符串显示所有向脚本传递的参数。<br>如<code>&quot;$*&quot;</code>用「”」括起来的情况、以”$1 $2 … $n”的形式输出所有参数。</td></tr><tr><td><code>$$</code></td><td>脚本运行的当前进程ID号</td></tr><tr><td><code>$!</code></td><td>后台运行的最后一个进程的ID号</td></tr><tr><td><code>$@</code></td><td>与<code>$*</code>相同，但是使用时加引号，并在引号中返回每个参数。<br>如”$@”用「”」括起来的情况、以”$1” “$2” … “$n” 的形式输出所有参数。</td></tr><tr><td><code>$-</code></td><td>显示Shell使用的当前选项，与set命令功能相同。</td></tr><tr><td><code>$?</code></td><td>显示最后命令的退出状态。0表示没有错误，其他任何值表明有错误。</td></tr></tbody></table></blockquote><h2 id="3-数组"><a href="#3-数组" class="headerlink" title="3. 数组"></a>3. 数组</h2><pre><code class="bash">#!/bin/bashmy_array=(A B &quot;C&quot; D)echo &quot;第一个元素为: ${my_array[0]}&quot;echo &quot;第二个元素为: ${my_array[1]}&quot;echo &quot;第三个元素为: ${my_array[2]}&quot;echo &quot;第四个元素为: ${my_array[3]}&quot;echo &quot;数组的元素为: ${my_array[*]}&quot;echo &quot;数组的元素为: ${my_array[@]}&quot;echo &quot;数组元素个数为: ${#my_array[*]}&quot;echo &quot;数组元素个数为: ${#my_array[@]}&quot;</code></pre><p>执行结果如下：</p><pre><code class="yml">第一个元素为: A第二个元素为: B第三个元素为: C第四个元素为: D数组的元素为: A B C D数组的元素为: A B C D数组元素个数为: 4数组元素个数为: 4</code></pre><h2 id="4-基本运算符"><a href="#4-基本运算符" class="headerlink" title="4. 基本运算符"></a>4. 基本运算符</h2><blockquote><p>原生 bash 不支持简单的数学运算，但是可以通过其他命令来实现，例如 awk 和 expr，expr 最常用。</p></blockquote><p>expr 是一款表达式计算工具，使用它能完成表达式的求值操作。</p><h3 id="①-算数运算符"><a href="#①-算数运算符" class="headerlink" title="① 算数运算符"></a>① 算数运算符</h3><pre><code class="bash">#!/bin/bashecho &quot;2加2等于&quot;`expr 2 + 2`echo &quot;2减2等于&quot;`expr 2 - 2`echo &quot;2乘2等于&quot;`expr 2 \* 2`echo &quot;2除2等于&quot;`expr 2 / 2`echo &quot;2除2取余&quot;`expr 2 % 2`</code></pre><h3 id="②-关系运算符"><a href="#②-关系运算符" class="headerlink" title="② 关系运算符"></a>② 关系运算符</h3><pre><code class="bash">#!/bin/basha=10b=20if [ $a -eq $b ] # 检测两个数是否相等，相等返回 true。if [ $a -ne $b ] # 检测两个数是否不相等，不相等返回 true。if [ $a -gt $b ] # 检测左边的数是否大于右边的，如果是，则返回 true。if [ $a -lt $b ] # 检测左边的数是否小于右边的，如果是，则返回 true。if [ $a -ge $b ] # 检测左边的数是否大于等于右边的，如果是，则返回 true。if [ $a -le $b ] # 检测左边的数是否小于等于右边的，如果是，则返回 true。</code></pre><h3 id="③-布尔运算符"><a href="#③-布尔运算符" class="headerlink" title="③ 布尔运算符"></a>③ 布尔运算符</h3><pre><code class="bash">#!/bin/bashif [ ! false ]       # 非运算，返回 trueif [ true -o false ] # 或运算，返回 trueif [ true -a false ] # 与运算，返回 false</code></pre><h3 id="④-逻辑运算符"><a href="#④-逻辑运算符" class="headerlink" title="④ 逻辑运算符"></a>④ 逻辑运算符</h3><pre><code class="bash">#!/bin/basha=10b=20if [[ $a -lt $b &amp;&amp; $a -gt $b ]]   # 逻辑的 AND, 返回 falseif [ $a -lt $b ] &amp;&amp; [ $a -gt $b ] # 逻辑的 AND, 返回 falseif [[ $a -lt $b || $a -gt $b ]]   # 逻辑的 OR, 返回 trueif [ $a -lt $b ] || [ $a -gt $b ] # 逻辑的 OR, 返回 true</code></pre><h3 id="⑤-字符串运算符"><a href="#⑤-字符串运算符" class="headerlink" title="⑤ 字符串运算符"></a>⑤ 字符串运算符</h3><pre><code class="bash">#!/bin/basha=&quot;abc&quot;b=&quot;efg&quot;if [ $a = $b ]   # 检测两个字符串是否相等，相等返回 true。if [ $a != $b ]  # 检测两个字符串是否相等，不相等返回 true。if [ -z $a ]     # 检测字符串长度是否为0，为0返回 true。if [ -n &quot;$a&quot; ]   # 检测字符串长度是否为0，不为0返回 true。if [ $a ]        # 检测字符串是否为空，不为空返回 true。</code></pre><h3 id="⑥-文件测试运算符"><a href="#⑥-文件测试运算符" class="headerlink" title="⑥ 文件测试运算符"></a>⑥ 文件测试运算符</h3><p>文件测试运算符用于检测 Unix 文件的各种属性。</p><table><thead><tr><th>操作符</th><th>说明</th></tr></thead><tbody><tr><td>-b file</td><td>检测文件是否是块设备文件，如果是，则返回 true。</td></tr><tr><td>-c file</td><td>检测文件是否是字符设备文件，如果是，则返回 true。</td></tr><tr><td>-d file</td><td>检测文件是否是目录，如果是，则返回 true。</td></tr><tr><td>-f file</td><td>检测文件是否是普通文件（既不是目录，也不是设备文件），如果是，则返回 true。</td></tr><tr><td>-g file</td><td>检测文件是否设置了 SGID 位，如果是，则返回 true。</td></tr><tr><td>-k file</td><td>检测文件是否设置了粘着位(Sticky Bit)，如果是，则返回 true。</td></tr><tr><td>-p file</td><td>检测文件是否是有名管道，如果是，则返回 true。</td></tr><tr><td>-u file</td><td>检测文件是否设置了 SUID 位，如果是，则返回 true。</td></tr><tr><td>-r file</td><td>检测文件是否可读，如果是，则返回 true。</td></tr><tr><td>-w file</td><td>检测文件是否可写，如果是，则返回 true。</td></tr><tr><td>-x file</td><td>检测文件是否可执行，如果是，则返回 true。</td></tr><tr><td>-s file</td><td>检测文件是否为空（文件大小是否大于0），不为空返回 true。</td></tr><tr><td>-e file</td><td>检测文件（包括目录）是否存在，如果是，则返回 true。</td></tr></tbody></table><h2 id="5-echo"><a href="#5-echo" class="headerlink" title="5. echo"></a>5. echo</h2><h3 id="①-命令格式"><a href="#①-命令格式" class="headerlink" title="① 命令格式"></a>① 命令格式</h3><pre><code class="bash">#!/bin/bashecho &quot;It is a test&quot;echo It is a testecho &quot;\&quot;It is a test\&quot;&quot;      # 转义name=Chrisecho &quot;$name is handsome&quot;echo -e &quot;OK! \n&quot;             # 显示换行 -e 开启转义echo &quot;It is a test&quot; &gt; myfile # 显示结果定向至文件echo &#39;$name\&quot;&#39;               # 原样输入字符串，不进行转义或取变量（使用单引号）echo `date`                  # 显示命令执行结构</code></pre><h3 id="②-颜色显示"><a href="#②-颜色显示" class="headerlink" title="② 颜色显示"></a>② 颜色显示</h3><pre><code class="bash">echo -e &quot;\033[字背景颜色；文字颜色m字符串\033[0m&quot;echo -e “\033[30m 黑色字 \033[0m”echo -e “\033[31m 红色字 \033[0m”echo -e “\033[32m 绿色字 \033[0m”echo -e “\033[33m 黄色字 \033[0m”echo -e “\033[34m 蓝色字 \033[0m”echo -e “\033[35m 紫色字 \033[0m”echo -e “\033[36m 天蓝字 \033[0m”echo -e “\033[37m 白色字 \033[0m”echo -e “\033[40;37m 黑底白字 \033[0m”echo -e “\033[41;37m 红底白字 \033[0m”echo -e “\033[42;37m 绿底白字 \033[0m”echo -e “\033[43;37m 黄底白字 \033[0m”echo -e “\033[44;37m 蓝底白字 \033[0m”echo -e “\033[45;37m 紫底白字 \033[0m”echo -e “\033[46;37m 天蓝底白字 \033[0m”echo -e “\033[47;30m 白底黑字 \033[0m”\33[0m 关闭所有属性\33[1m 设置高亮度\33[4m 下划线\33[5m 闪烁\33[7m 反显\33[8m 消隐\33[30m — \33[37m 设置前景色\33[40m — \33[47m 设置背景色\33[nA 光标上移n行\33[nB 光标下移n行\33[nC 光标右移n行\33[nD 光标左移n行\33[y;xH设置光标位置\33[2J 清屏\33[K 清除从光标到行尾的内容\33[s 保存光标位置\33[u 恢复光标位置\33[?25l 隐藏光标\33[?25h 显示光标</code></pre><h2 id="6-sprintf"><a href="#6-sprintf" class="headerlink" title="6. sprintf"></a>6. sprintf</h2><pre><code class="bash">#!/bin/bashprintf &quot;%-10s %-8s %-4s\n&quot; 姓名 性别 体重kg  printf &quot;%-10s %-8s %-4.2f\n&quot; 郭靖 男 66.1234printf &quot;%-10s %-8s %-4.2f\n&quot; 杨过 男 48.6543printf &quot;%-10s %-8s %-4.2f\n&quot; 郭芙 女 47.9876</code></pre><p>结果：</p><pre><code>姓名     性别   体重kg郭靖     男      66.12杨过     男      48.65郭芙     女      47.99</code></pre><blockquote><p><code>%s %c %d %f</code> 都是格式替代符<br><code>d</code>: Decimal 十进制整数 – 对应位置参数必须是十进制整数，否则报错！<br><code>s</code>: String 字符串 – 对应位置参数必须是字符串或者字符型，否则报错！<br><code>c</code>: Char 字符 – 对应位置参数必须是字符串或者字符型，否则报错！<br><code>f</code>: Float 浮点 – 对应位置参数必须是数字型，否则报错！<br><code>%-10s</code> 指一个宽度为10个字符（-表示左对齐，没有则表示右对齐）,任何字符都会被显示在10个字符宽的字符内，如果不足则自动以空格填充，超过也会将内容全部显示出来。<br><code>%-4.2f</code> 指格式化为小数，其中.2指保留2位小数。</p></blockquote><h2 id="7-test"><a href="#7-test" class="headerlink" title="7. test"></a>7. test</h2><p>Shell中的 test 命令用于检查某个条件是否成立，它可以进行数值、字符和文件三个方面的测试。</p><pre><code class="bash">#!/bin/bashnum1=100num2=100if test $[num1] -eq $[num2]</code></pre><h2 id="8-流程控制"><a href="#8-流程控制" class="headerlink" title="8. 流程控制"></a>8. 流程控制</h2><h3 id="①-if-else"><a href="#①-if-else" class="headerlink" title="① if-else"></a>① if-else</h3><pre><code class="bash">#!/bin/basha=10b=20if [ $a == $b ]then   echo &quot;a 等于 b&quot;elif [ $a -gt $b ]then   echo &quot;a 大于 b&quot;elif [ $a -lt $b ]then   echo &quot;a 小于 b&quot;else   echo &quot;没有符合的条件&quot;fi</code></pre><h3 id="②-for"><a href="#②-for" class="headerlink" title="② for"></a>② for</h3><pre><code class="bash">#!/bin/bashfor loop in 1 2 3 4 5do    echo &quot;The value is: $loop&quot;done</code></pre><h3 id="③-while"><a href="#③-while" class="headerlink" title="③ while"></a>③ while</h3><pre><code class="bash">#!/bin/bashint=1while(( $int&lt;=5 ))do    echo $int    let &quot;int++&quot;done</code></pre><h3 id="④-case"><a href="#④-case" class="headerlink" title="④ case"></a>④ case</h3><pre><code class="bash">#!/bin/bashecho &#39;输入 1 到 4 之间的数字:&#39;echo &#39;你输入的数字为:&#39;read aNumcase $aNum in    1)  echo &#39;你选择了 1&#39;    ;;    2)  echo &#39;你选择了 2&#39;    ;;    3)  echo &#39;你选择了 3&#39;    ;;    4)  echo &#39;你选择了 4&#39;    ;;    *)  echo &#39;你没有输入 1 到 4 之间的数字&#39;    ;;esac</code></pre><h3 id="⑤-break"><a href="#⑤-break" class="headerlink" title="⑤ break"></a>⑤ break</h3><p>break命令允许跳出所有循环（终止执行后面的所有循环）。</p><pre><code class="bash">#!/bin/bashwhile :do    echo -n &quot;输入 1 到 5 之间的数字:&quot;    read aNum    case $aNum in        1|2|3|4|5) echo &quot;你输入的数字为 $aNum!&quot;        ;;        *) echo &quot;你输入的数字不是 1 到 5 之间的! 游戏结束&quot;            break        ;;    esacdone</code></pre><h3 id="⑥-continue"><a href="#⑥-continue" class="headerlink" title="⑥ continue"></a>⑥ continue</h3><p>跳出当前循环。</p><pre><code class="bash">#!/bin/bashwhile :do    echo -n &quot;输入 1 到 5 之间的数字: &quot;    read aNum    case $aNum in        1|2|3|4|5) echo &quot;你输入的数字为 $aNum!&quot;        ;;        *) echo &quot;你输入的数字不是 1 到 5 之间的!&quot;            continue            echo &quot;游戏结束&quot;        ;;    esacdone</code></pre><h3 id="⑦-until"><a href="#⑦-until" class="headerlink" title="⑦ until"></a>⑦ until</h3><pre><code class="bash">#!/bin/basha=0until [ ! $a -lt 10 ]do   echo $a   a=`expr $a + 1`done</code></pre><h2 id="9-函数"><a href="#9-函数" class="headerlink" title="9. 函数"></a>9. 函数</h2><pre><code class="bash">#!/bin/bashfunWithParam(){    echo &quot;第一个参数为 $1 !&quot;    echo &quot;第二个参数为 $2 !&quot;    echo &quot;第十个参数为 $10 !&quot;    echo &quot;第十个参数为 ${10} !&quot;    echo &quot;第十一个参数为 ${11} !&quot;    echo &quot;参数总数有 $# 个!&quot;    echo &quot;作为一个字符串输出所有参数 $* !&quot;}funWithParam 1 2 3 4 5 6 7 8 9 34 73</code></pre><p>结果：</p><pre><code>第一个参数为 1 !第二个参数为 2 !第十个参数为 10 !第十个参数为 34 !第十一个参数为 73 !参数总数有 11 个!作为一个字符串输出所有参数 1 2 3 4 5 6 7 8 9 34 73 !</code></pre><h2 id="10-输入输出"><a href="#10-输入输出" class="headerlink" title="10. 输入输出"></a>10. 输入输出</h2><pre><code class="bash">#!/bin/bashwho &gt; today.log # 执行结果覆盖到文件 today.logecho &quot;菜鸟教程：www.runoob.com&quot; &gt;&gt; today.log # 执行结果追加到文件 today.logwc -l &lt; today.log # 统计 today.log 行数wc -l &lt;&lt; EOF    李白    苏轼    王勃EOF</code></pre><h2 id="11-文件包含"><a href="#11-文件包含" class="headerlink" title="11. 文件包含"></a>11. 文件包含</h2><p>test1.sh</p><pre><code class="bash">#!/bin/bashname=&quot;Chris&quot;</code></pre><p>test2.sh</p><pre><code class="bash">#!/bin/bash#使用 . 号来引用test1.sh 文件. ./test1.sh# 或者使用以下包含文件代码# source ./test1.shecho $name</code></pre><blockquote><p>注：被包含的文件 test1.sh 不需要可执行权限。</p></blockquote><h2 id="reference"><a href="#reference" class="headerlink" title="reference:"></a>reference:</h2><p>[1] <a href="http://www.runoob.com/linux/linux-shell.html" target="_blank" rel="noopener">http://www.runoob.com/linux/linux-shell.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="运维" scheme="https://jiangxingye.github.io/categories/%E8%BF%90%E7%BB%B4/"/>
    
    
      <category term="linux" scheme="https://jiangxingye.github.io/tags/linux/"/>
    
      <category term="shell" scheme="https://jiangxingye.github.io/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>nginx配置记录</title>
    <link href="https://jiangxingye.github.io/2018/02/08/nginx-config/"/>
    <id>https://jiangxingye.github.io/2018/02/08/nginx-config/</id>
    <published>2018-02-08T01:19:09.000Z</published>
    <updated>2019-09-02T13:02:59.998Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="启用https"><a href="#启用https" class="headerlink" title="启用https"></a>启用https</h2><h3 id="1-购买免费证书"><a href="#1-购买免费证书" class="headerlink" title="1.购买免费证书"></a>1.购买免费证书</h3><p>登录阿里云 -&gt; 控制台 -&gt; 安全（云盾） -&gt; CA证书服务 -&gt; 购买证书<br><img src="http://img.xiangzhangshugongyi.com/Fr8xZ-Z1ylYPcoN1PCTk_5SDm6TM.png" alt="购买免费证书"></p><h3 id="2-补全证书信息"><a href="#2-补全证书信息" class="headerlink" title="2.补全证书信息"></a>2.补全证书信息</h3><p>点击补全，绑定域名</p><h3 id="3-下载并配置"><a href="#3-下载并配置" class="headerlink" title="3.下载并配置"></a>3.下载并配置</h3><p>选择下载 证书for nginx<br><img src="http://img.xiangzhangshugongyi.com/FnMUOU4IZY2ZbMZcqggp4v7JHtej.png" alt="下载证书"></p><p>上面这个页面有相关的配置信息，下面简单介绍：</p><p>① 将下载文件中的 <code>*.pem</code>、<code>*.key</code>, 拷贝到 nginx 目录下 的 <code>cert</code> , 当然也可以是其他目录<br>② 修改 <code>nginx.conf</code></p><pre><code class="conf">server {      listen       443 ssl;      server_name  xiangzhangshugongyi.com;      ssl_certificate      cert/214487958220243.pem;      ssl_certificate_key  cert/214487958220243.key;      ssl_session_cache    shared:SSL:1m;      ssl_session_timeout  5m;      ssl_ciphers  HIGH:!aNULL:!MD5;      ssl_prefer_server_ciphers  on;      location / {          proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;          proxy_set_header Host $http_host;          proxy_set_header X-Forwarded-Proto https;          proxy_redirect off;          proxy_connect_timeout      240;          proxy_send_timeout         240;          proxy_read_timeout         240;          # note, there is not SSL here! plain HTTP is used          proxy_pass http://127.0.0.1:8080;      }  }</code></pre><p>③ 重启 nginx，通过 证书绑定域名进行 https 访问到 服务器跑在 8080 的服务<br><img src="http://img.xiangzhangshugongyi.com/FtTXB9QIYoZOlPFKsGg-ImxbL58N.png" alt="通过https访问"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="运维" scheme="https://jiangxingye.github.io/categories/%E8%BF%90%E7%BB%B4/"/>
    
    
      <category term="nginx" scheme="https://jiangxingye.github.io/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>[转]谈谈Java中的语法糖</title>
    <link href="https://jiangxingye.github.io/2017/11/27/java-grammatical-sugar/"/>
    <id>https://jiangxingye.github.io/2017/11/27/java-grammatical-sugar/</id>
    <published>2017-11-27T14:51:45.000Z</published>
    <updated>2019-09-02T13:02:59.978Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>语法糖（Syntactic Sugar），也称糖衣语法，指在计算机语言中添加的某种语法，这种语法对语言本身功能来说没有什么影响，只是为了方便程序员的开发，提高开发效率。说白了，语法糖就是对现有语法的一个封装。</p></blockquote><p>Java作为一种与平台无关的高级语言，当然也含有语法糖，这些语法糖并不被虚拟机所支持，在编译成字节码阶段就自动转换成简单常用语法。一般来说Java中的语法糖主要有以下几种：</p><ol><li>泛型与类型擦除</li><li>自动装箱与拆箱，变长参数、</li><li>增强for循环</li><li>内部类与枚举类</li></ol><h2 id="泛型与类型擦除"><a href="#泛型与类型擦除" class="headerlink" title="泛型与类型擦除"></a>泛型与类型擦除</h2><p>Java语言并不是一开始就支持泛型的。在早期的JDK中，只能通过Object类是所有类型的父类和强制类型转换来实现泛型的功能。强制类型转换的缺点就是把编译期间的问题延迟到运行时，JVM并不能为我们提供编译期间的检查。</p><p>在JDK1.5中，Java语言引入了泛型机制。但是这种泛型机制是通过类型擦除来实现的，即Java中的泛型只在程序源代码中有效（源代码阶段提供类型检查），在编译后的字节码中自动用强制类型转换进行替代。也就是说，Java语言中的泛型机制其实就是一颗语法糖，相较与C++、C#相比，其泛型实现实在是不那么优雅。</p><pre><code class="java">/*** 在源代码中存在泛型*/public static void main(String[] args) {    Map&lt;String,String&gt; map = new HashMap&lt;String,String&gt;();    map.put(&quot;hello&quot;,&quot;你好&quot;);    String hello = map.get(&quot;hello&quot;);    System.out.println(hello);}</code></pre><p>当上述源代码被编译为class文件后，泛型被擦除且引入强制类型转换</p><pre><code class="java">public static void main(String[] args) {    HashMap map = new HashMap(); //类型擦除    map.put(&quot;hello&quot;, &quot;你好&quot;);    String hello = (String)map.get(&quot;hello&quot;);//强制转换    System.out.println(hello);}</code></pre><h2 id="自动装箱与拆箱"><a href="#自动装箱与拆箱" class="headerlink" title="自动装箱与拆箱"></a>自动装箱与拆箱</h2><blockquote><p>Java中的自动装箱与拆箱指的是基本数据类型与他们的包装类型之间的相互转换。</p></blockquote><p>我们知道Java是一门面向对象的语言，在Java世界中有一句话是这么说的：“万物皆对象”。但是Java中的基本数据类型却不是对象，他们不需要进行new操作，也不能调用任何方法，这在使用的时候有诸多不便。因此Java为这些基本类型提供了包装类，并且为了使用方便，提供了自动装箱与拆箱功能。自动装箱与拆箱在使用的过程中，其实是一个语法糖，内部还是调用了相应的函数进行转换。</p><p>下面代码演示了自动装箱和拆箱功能</p><pre><code class="java">public static void main(String[] args) {    Integer a = 1;    int b = 2;    int c = a + b;    System.out.println(c);}</code></pre><p>经过编译后，代码如下</p><pre><code class="java">public static void main(String[] args) {    Integer a = Integer.valueOf(1); // 自动装箱    byte b = 2;    int c = a.intValue() + b;//自动拆箱    System.out.println(c);}</code></pre><h2 id="变长参数"><a href="#变长参数" class="headerlink" title="变长参数"></a>变长参数</h2><blockquote><p>所谓变长参数，就是方法可以接受长度不定确定的参数</p></blockquote><p>变长参数特性是在JDK1.5中引入的，使用变长参数有两个条件，一是变长的那一部分参数具有相同的类型，二是变长参数必须位于方法参数列表的最后面。变长参数同样是Java中的语法糖，其内部实现是Java数组。</p><pre><code class="java">public class Varargs {    public static void print(String... args) {        for(String str : args){            System.out.println(str);        }    }    public static void main(String[] args) {        print(&quot;hello&quot;, &quot;world&quot;);    }}</code></pre><p>编译为class文件后如下，从中可以很明显的看出变长参数内部是通过数组实现的</p><pre><code class="java">public class Varargs {    public Varargs() {    }    public static void print(String... args) {        String[] var1 = args;        int var2 = args.length;        //增强for循环的数组实现方式        for(int var3 = 0; var3 &lt; var2; ++var3) {            String str = var1[var3];            System.out.println(str);        }    }    public static void main(String[] args) {        //变长参数转换为数组        print(new String[]{&quot;hello&quot;, &quot;world&quot;});    }}</code></pre><h2 id="增强for循环"><a href="#增强for循环" class="headerlink" title="增强for循环"></a>增强for循环</h2><blockquote><p>增强for循环与普通for循环相比，功能更强并且代码更简洁</p></blockquote><p>增强for循环的对象要么是一个数组，要么实现了Iterable接口。这个语法糖主要用来对数组或者集合进行遍历，其在循环过程中不能改变集合的大小。</p><pre><code class="java">public static void main(String[] args) {    String[] params = new String[]{&quot;hello&quot;,&quot;world&quot;};    //增强for循环对象为数组    for(String str : params){        System.out.println(str);    }    List&lt;String&gt; lists = Arrays.asList(&quot;hello&quot;,&quot;world&quot;);    //增强for循环对象实现Iterable接口    for(String str : lists){        System.out.println(str);    }}</code></pre><p>编译后的class文件为</p><pre><code class="java">public static void main(String[] args) {   String[] params = new String[]{&quot;hello&quot;, &quot;world&quot;};   String[] lists = params;   int var3 = params.length;   //数组形式的增强for退化为普通for   for(int str = 0; str &lt; var3; ++str) {       String str1 = lists[str];       System.out.println(str1);   }   List var6 = Arrays.asList(new String[]{&quot;hello&quot;, &quot;world&quot;});   Iterator var7 = var6.iterator();   //实现Iterable接口的增强for使用iterator接口进行遍历   while(var7.hasNext()) {       String var8 = (String)var7.next();       System.out.println(var8);   }}</code></pre><h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><blockquote><p>内部类就是定义在一个类内部的类</p></blockquote><p>Java语言中之所以引入内部类，是因为有些时候一个类只在另一个类中有用，我们不想让其在另外一个地方被使用。内部类之所以是语法糖，是因为其只是一个编译时的概念，一旦编译完成，编译器就会为内部类生成一个单独的class文件，名为outer$innter.class。</p><pre><code class="java">public class Outer {    class Inner{    }}</code></pre><p>使用javac编译后，生成两个class文件Outer.class和Outer$Inner.class，其中Outer$Inner.class的内容如下：</p><pre><code class="java">class Outer$Inner {    Outer$Inner(Outer var1) {        this.this$0 = var1;    }}</code></pre><p>内部类分为四种：成员内部类、局部内部类、匿名内部类、静态内部类，每一种都有其用法，这里就不介绍了</p><h2 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h2><blockquote><p>枚举类型就是一些具有相同特性的类常量</p></blockquote><p>java中类的定义使用class，枚举类的定义使用enum。在Java的字节码结构中，其实并没有枚举类型，枚举类型只是一个语法糖，在编译完成后被编译成一个普通的类。这个类继承java.lang.Enum，并被final关键字修饰。</p><pre><code class="java">public enum Fruit {    APPLE,ORINGE}</code></pre><p>使用jad对编译后的class文件进行反编译后得到</p><pre><code class="java">//继承java.lang.Enum并声明为finalpublic final class Fruit extends Enum{    public static Fruit[] values()    {        return (Fruit[])$VALUES.clone();    }    public static Fruit valueOf(String s)    {        return (Fruit)Enum.valueOf(Fruit, s);    }    private Fruit(String s, int i)    {        super(s, i);    }    //枚举类型常量    public static final Fruit APPLE;    public static final Fruit ORANGE;    private static final Fruit $VALUES[];//使用数组进行维护    static    {        APPLE = new Fruit(&quot;APPLE&quot;, 0);        ORANGE = new Fruit(&quot;ORANGE&quot;, 1);        $VALUES = (new Fruit[] {            APPLE, ORANGE        });    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="后端" scheme="https://jiangxingye.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="java" scheme="https://jiangxingye.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>PostgreSQL事务及隔离级别</title>
    <link href="https://jiangxingye.github.io/2017/11/09/PostgreSQL%E4%BA%8B%E7%89%A9%E5%8F%8A%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/"/>
    <id>https://jiangxingye.github.io/2017/11/09/PostgreSQL事物及隔离级别/</id>
    <published>2017-11-08T16:07:33.000Z</published>
    <updated>2019-09-02T13:02:59.980Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>PostgreSQL中提供了多种数据完整性的保证机制。如：约束、触发器、事务和锁管理等。</p><p>事务主要是为了保证一组相关数据库的操作能全部执行成功，从而保证数据的完整性。锁机制主要是控制多个用户对同一数据进行操作，使用锁机制可以解决并发问题。</p><h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><p>事务是用户对一个数据库操作的一个序列，这些操作要么全做，要么全不做，是一个不可分割的单位。</p><p>事务管理的常用语句如下：</p><pre><code class="sql">BEGIN;SQL语句1;SQL语句2;...COMMIT;</code></pre><p>事务块是指包围在BEGIN和COMMIT之间的语句。在PostgreSQL9中，常用的事务块管理语句含义如下：</p><blockquote><p><strong>START TRANSACTION</strong>：此命令表示开始一个新的事务块.<br><strong>BEGIN</strong>：初始化一个事务块。在BEGIN命令后的语句都将在一个事务里面执行，知道遇见COMMIT或ROLLBACK。它和START TRANSACTION是一样的。<br><strong>COMMIT</strong>：提交事务。<br><strong>ROLLBACK</strong>：事务失败时执行回滚操作。<br><strong>SET TRANSACTION</strong>：设置当前事务的特性。对后面的事务没有影响。</p></blockquote><h3 id="事务隔离及并发控制"><a href="#事务隔离及并发控制" class="headerlink" title="事务隔离及并发控制"></a>事务隔离及并发控制</h3><p>PostgreSQL是一个支持多用户的数据库，当多个用户操作同一数据库时，并发控制要保证所有用户可以高效的访问的同时不破坏数据的完整性。</p><p>数据库中数据的并发操作经常发生，而对数据的并发操作会带来下面的一些问题：</p><ol><li>脏读<br>一个事务读取了另一个未提交事务写入的数据。</li><li>不可重复读<br>一个事务重新读取前面读取过的数据，发现该数据已经被另一个已经提交的事务修改。</li><li>幻读<br>一个事务重新执行一个查询，返回符合查询条件的行的集合，发现满足查询条件的行的集合因为其它最近提交的事务而发生了改变。</li></ol><p>SQL标准定义了四个级别的事务隔离。</p><p>| 隔离级别 | 脏读 | 幻读 | 不可重复性读取 |<br>| :- | :- |<br>|读未提交    |可能    |可能    |可能|<br>|读已提交    |不可能|    可能    |可能|<br>|可重复读    |不可能    |可能    |不可能|<br>|可串行读    |不可能    |不可能    |不可能|</p><p>在PostgreSQL中，可以请求4种隔离级别中的任意一种。但是在内部，实际上只有两种独立的隔离级别，分别对应已提交和可串行化。如果选择了读未提交的级别，实际上使用的是读已提交，在选择可重复读级别的时候，实际上用的是可串行化，所以实际的隔离级别可能比选择的更严格。这是SQL标准允许的：4种隔离级别只定义了哪种现象不能发生，但是没有定义哪种现象一定发生。</p><p>PostgreSQL只提供两种隔离级别的原因是，这是把标准的隔离级别与多版本并发控制架构映射相关的唯一合理方法。</p><ol><li>读已提交<br>这是PostgreSQL中默认的隔离级别，当一个事务运行在这个隔离级别时，一个SELECT查询只能看到查询开始前已提交的数据，而无法看到未提交的数据或者在查询期间其他的事务已提交的数据。</li><li>可串行化<br>可串行化提供最严格的事务隔离。这个级别模拟串行的事务执行，就好像事务是一个接着一个串行的执行。不过，这个级别的应用必须准备在串行化失败的时候重新启动事务。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="数据库" scheme="https://jiangxingye.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="PostgreSQL" scheme="https://jiangxingye.github.io/tags/PostgreSQL/"/>
    
  </entry>
  
  <entry>
    <title>[转]字符编解码的故事（ASCII，ANSI，Unicode，Utf-8区别）</title>
    <link href="https://jiangxingye.github.io/2017/09/25/ascii-ansi-unicode-utf-8%EF%BC%89/"/>
    <id>https://jiangxingye.github.io/2017/09/25/ascii-ansi-unicode-utf-8）/</id>
    <published>2017-09-25T11:15:00.000Z</published>
    <updated>2019-09-02T13:03:00.032Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>很久很久以前，有一群人，他们决定用8个可以开合的晶体管来组合成不同的状态，以表示世界上的万物。他们认为8个开关状态作为原子单位很好，于是他们把这称为”字节”。</p><p>再后来，他们又做了一些可以处理这些字节的机器，机器开动了，可以用字节来组合出更多的状态，状态开始变来变去。他们看到这样是好的，于是它们就这机器称为”计算机”。</p><p>开始计算机只在美国用。八位的字节一共可以组合出256（2的8次方）种不同的状态。</p><p>他们把其中的编号从0开始的32种状态分别规定了特殊的用途，一但终端设备或者打印机遇上这些约定好的字节时，就要做一些约定的动作。遇上 00x10, 终端就换行，遇上0x07, 终端就向人们嘟嘟叫，例好遇上0x1b, 打印机就打印反白的字，对于终端就用彩色显示字母。他们看到这样很好，于是就把这些0x20（十进制32）以下的字节状态称为”控制码”。</p><p>他们又把所有的空格、标点符号、数字、大小写字母分别用连续的字节状态表示，一直编到了第127号，这样计算机就可以用不同字节来存储英语的 文字了。大家看到这样，都感觉很好，于是大家都把这个方案叫做 ANSI 的”Ascii”编码（American Standard Code for Information Interchange，美国信息互换标准代码）。当时世界上所有的计算机都用同样的ASCII方案来保存英文文字。</p><p>后来，就像建造巴比伦塔一样，世界各地的都开始使用计算机，但是很多国家用的不是英文，他们用到的许多字母在ASCII中根本没有，为了也可以在计算机中保存他们的文字，他们决定采用127号之后的空位来表示这些新的字母、符号，还加入了很多画表格时需要用下到的横线、竖线、交叉等形状，一直把序号编到了最后一个状态255。从128到255这一页的字符集被称”扩展字符集”。从此之后，贪婪的人类再没有新的状态可以用了，美帝国主义可能没有想到还有第三世界国家的人们也希望可以用到计算机吧！</p><p>等中国人们得到计算机时，已经没有可以利用的字节状态来表示汉字，况且有6000多个常用汉字需要保存呢。但是这难不倒智慧的中国人民，我们不客气地把那些127号之后的奇异符号们直接取消掉，并且规定：一个小于127的字符的意义与原来相同，但两个大于127的字符连在一起时，就表示一个汉字，前面的一个字节（他称之为高字节）从0xA1用到 0xF7，后面一个字节（低字节）从0xA1到0xFE，这样我们就可以组合出大约7000多个简体汉字了。在这些编码里，我们还把数学符号、罗马希腊的字母、日文的假名们都编进去了，连在 ASCII 里本来就有的数字、标点、字母都统统重新编了两个字节长的编码，这就是常说的”全角”字符，而原来在127号以下的那些就叫”半角”字符了。</p><p>中国人民看到这样很不错，于是就把这种汉字方案叫做”GB2312”。GB2312 是对 ASCII 的中文扩展。</p><p>但是中国的汉字太多了，我们很快就就发现有许多人的人名没有办法在这里打出来，特别是某些很会麻烦别人的国家领导人（如朱镕基的“镕”字）。于是我们不得不继续把 GB2312 没有用到的码位找出来老实不客气地用上。</p><p>后来还是不够用，于是干脆不再要求低字节一定是127号之后的内码，只要第一个字节是大于127就固定表示这是一个汉字的开始，不管后面跟的是不是扩展字符集里的内容。结果扩展之后的编码方案被称为 GBK 标准，GBK 包括了 GB2312 的所有内容，同时又增加了近20000个新的汉字（包括繁体字）和符号。</p><p>后来少数民族也要用电脑了，于是我们再扩展，又加了几千个新的少数民族的字，GBK 扩成了 GB18030。从此之后，中华民族的文化就可以在计算机时代中传承了。</p><p>中国的程序员们看到这一系列汉字编码的标准是好的，于是通称他们叫做 “DBCS”（Double Byte Charecter Set 双字节字符集）。在DBCS系列标准里，最大的特点是两字节长的汉字字符和一字节长的英文字符并存于同一套编码方案里，因此他们写的程序为了支持中文处理，必须要注意字串里的每一个字节的值，如果这个值是大于127的，那么就认为一个双字节字符集里的字符出现了。那时候凡是受过加持，会编程的计算机僧侣们都要每天念下面这个咒语数百遍：</p><p>“一个汉字算两个英文字符！一个汉字算两个英文字符……”</p><p>因为当时各个国家都像中国这样搞出一套自己的编码标准，结果互相之间谁也不懂谁的编码，谁也不支持别人的编码，连大陆和台湾这样只相隔了150海里，使用着同一种语言的兄弟地区，也分别采用了不同的 DBCS 编码方案——当时的中国人想让电脑显示汉字，就必须装上一个”汉字系统”，专门用来处理汉字的显示、输入的问题，但是那个台湾的愚昧封建人士写的算命程序就必须加装另一套支持 BIG5 编码的什么”倚天汉字系统”才可以用，装错了字符系统，显示就会乱了套！这怎么办？而且世界民族之林中还有那些一时用不上电脑的穷苦人民，他们的文字又怎么办？</p><p>真是计算机的巴比伦塔命题啊！</p><p>正在这时，大天使加百列及时出现了——一个叫 ISO （国际标谁化组织）的国际组织决定着手解决这个问题。他们采用的方法很简单：废了所有的地区性编码方案，重新搞一个包括了地球上所有文化、所有字母和符号的编码！他们打算叫它”Universal Multiple-Octet Coded Character Set”，简称 UCS, 俗称 “UNICODE”。</p><p>UNICODE 开始制订时，计算机的存储器容量极大地发展了，空间再也不成为问题了。于是 ISO 就直接规定必须用两个字节，也就是16位来统一表示所有的字符，对于ascii里的那些”半角”字符，UNICODE 包持其原编码不变，只是将其长度由原来的8位扩展为16位，而其他文化和语言的字符则全部重新统一编码。由于”半角”英文符号只需要用到低8位，所以其高 8位永远是0，因此这种大气的方案在保存英文文本时会多浪费一倍的空间。</p><p>这时候，从旧社会里走过来的程序员开始发现一个奇怪的现象：他们的strlen函数靠不住了，一个汉字不再是相当于两个字符了，而是一个！是 的，从 UNICODE 开始，无论是半角的英文字母，还是全角的汉字，它们都是统一的”一个字符”！同时，也都是统一的”两个字节”，请注意”字符”和”字节”两个术语的不同， “字节”是一个8位的物理存贮单元，而”字符”则是一个文化相关的符号。在UNICODE 中，一个字符就是两个字节。一个汉字算两个英文字符的时代已经快过去了。</p><p>从前多种字符集存在时，那些做多语言软件的公司遇上过很大麻烦，他们为了在不同的国家销售同一套软件，就不得不在区域化软件时也加持那个双字节字符集咒语，不仅要处处小心不要搞错，还要把软件中的文字在不同的字符集中转来转去。UNICODE 对于他们来说是一个很好的一揽子解决方案，于是从 Windows NT 开始，MS 趁机把它们的操作系统改了一遍，把所有的核心代码都改成了用 UNICODE 方式工作的版本，从这时开始，WINDOWS 系统终于无需要加装各种本土语言系统，就可以显示全世界上所有文化的字符了。</p><p>但是，UNICODE 在制订时没有考虑与任何一种现有的编码方案保持兼容，这使得 GBK 与UNICODE 在汉字的内码编排上完全是不一样的，没有一种简单的算术方法可以把文本内容从UNICODE编码和另一种编码进行转换，这种转换必须通过查表来进行。</p><p>如前所述，UNICODE 是用两个字节来表示为一个字符，他总共可以组合出65535不同的字符，这大概已经可以覆盖世界上所有文化的符号。如果还不够也没有关系，ISO已经准备了UCS-4方案，说简单了就是四个字节来表示一个字符，这样我们就可以组合出21亿个不同的字符出来（最高位有其他用途），这大概可以用到银河联邦成立那一天吧！</p><p>UNICODE 来到时，一起到来的还有计算机网络的兴起，UNICODE 如何在网络上传输也是一个必须考虑的问题，于是面向传输的众多 UTF（UCS Transfer Format）标准出现了，顾名思义，UTF8就是每次8个位传输数据，而UTF16就是每次16个位，只不过为了传输时的可靠性，从UNICODE到 UTF时并不是直接的对应，而是要过一些算法和规则来转换。</p><p>受到过网络编程加持的计算机僧侣们都知道，在网络里传递信息时有一个很重要的问题，就是对于数据高低位的解读方式，一些计算机是采用低位先发送的方法，例如我们PC机采用的 INTEL 架构；而另一些是采用高位先发送的方式。在网络中交换数据时，为了核对双方对于高低位的认识是否是一致的，采用了一种很简便的方法，就是在文本流的开始时向对方发送一个标志符——如果之后的文本是高位在位，那就发送”FEFF”，反之，则发送”FFFE”。不信你可以用二进制方式打开一个UTF-X格式的文件，看看开头两个字节是不是这两个字节？</p><p>下面是Unicode和UTF-8转换的规则</p><pre><code class="xml">UnicodeUTF-80000 - 007F0xxxxxxx0080 - 07FF110xxxxx 10xxxxxx0800 - FFFF1110xxxx 10xxxxxx 10xxxxxx</code></pre><p>例如”汉”字的Unicode编码是6C49。6C49在0800-FFFF之间，所以要用3字节模板：1110xxxx 10xxxxxx 10xxxxxx。将6C49写成二进制是：0110 1100 0100 1001，将这个比特流按三字节模板的分段方法分为0110 110001 001001，依次代替模板中的x，得到：1110-0110 10-110001 10-001001，即E6 B1 89，这就是其UTF8的编码。</p><p>讲到这里，我们再顺便说说一个很著名的奇怪现象：当你在 windows 的记事本里新建一个文件，输入”联通”两个字之后，保存，关闭，然后再次打开，你会发现这两个字已经消失了，代之的是几个乱码！呵呵，有人说这就是联通之所以拼不过移动的原因。</p><p>其实这是因为GB2312编码与UTF8编码产生了编码冲撞的原因。</p><p>当一个软件打开一个文本时，它要做的第一件事是决定这个文本究竟是使用哪种字符集的哪种编码保存的。软件一般采用三种方式来决定文本的字符集和编码：</p><p>检测文件头标识，提示用户选择，根据一定的规则猜测</p><p>最标准的途径是检测文本最开头的几个字节，开头字节 Charset/encoding,如下表：</p><pre><code class="xml">EF BB BF UTF-8FF FE UTF-16/UCS-2, little endianFE FF UTF-16/UCS-2, big endianFF FE 00 00 UTF-32/UCS-4, little endian.00 00 FE FF UTF-32/UCS-4, big-endian.</code></pre><p>当你新建一个文本文件时，记事本的编码默认是ANSI（代表系统默认编码，在中文系统中一般是GB系列编码）, 如果你在ANSI的编码输入汉字，那么他实际就是GB系列的编码方式，在这种编码下，”联通”的内码是：</p><pre><code class="xml">c1 1100 0001aa 1010 1010cd 1100 1101a8 1010 1000</code></pre><p>注意到了吗？第一二个字节、第三四个字节的起始部分的都是”110”和”10”，正好与UTF8规则里的两字节模板是一致的，</p><p>于是当我们再次打开记事本时，记事本就误认为这是一个UTF8编码的文件，让我们把第一个字节的110和第二个字节的10去掉，我们就得到了”00001 101010”，再把各位对齐，补上前导的0，就得到了”0000 0000 0110 1010”，不好意思，这是UNICODE的006A，也就是小写的字母”j”，而之后的两字节用UTF8解码之后是0368，这个字符什么也不是。这就是只有”联通”两个字的文件没有办法在记事本里正常显示的原因。</p><p>而如果你在”联通”之后多输入几个字，其他的字的编码不见得又恰好是110和10开始的字节，这样再次打开时，记事本就不会坚持这是一个utf8编码的文件，而会用ANSI的方式解读之，这时乱码又不出现了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="运维" scheme="https://jiangxingye.github.io/categories/%E8%BF%90%E7%BB%B4/"/>
    
    
      <category term="encoding" scheme="https://jiangxingye.github.io/tags/encoding/"/>
    
  </entry>
  
  <entry>
    <title>搭建dubbo+zookeeper平台</title>
    <link href="https://jiangxingye.github.io/2017/09/25/%E6%90%AD%E5%BB%BAdubbo+zookeeper%E5%B9%B3%E5%8F%B0/"/>
    <id>https://jiangxingye.github.io/2017/09/25/搭建dubbo+zookeeper平台/</id>
    <published>2017-09-25T08:29:07.000Z</published>
    <updated>2019-09-02T13:02:59.977Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文将介绍在SpringMVC+Spring+Mybatis项目中添加 <code>dubbo</code> 作为 <code>rpc</code> 服务。</p><p>文末有项目代码地址。</p><h2 id="一-搭建zookeeper"><a href="#一-搭建zookeeper" class="headerlink" title="一.搭建zookeeper"></a>一.搭建zookeeper</h2><p>使用 docker 一句话创建：</p><pre><code class="bash">docker run -dit --name zookeeper --hostname zookeeper-host -v /data:/data -p 2181:2181 jplock/zookeeper:latest</code></pre><h2 id="二-安装zkui（非必须）"><a href="#二-安装zkui（非必须）" class="headerlink" title="二.安装zkui（非必须）"></a>二.安装zkui（非必须）</h2><p>这个项目为 zookeeper 提供一个 web 的管理界面。当然我们也可以直接在zookeeper中使用命令查看，所以此步骤可以忽略</p><p>在开始前需要安装 Java 环境、Maven 环境。</p><ol><li>到 <a href="https://github.com/DeemOpen/zkui" target="_blank" rel="noopener">zkui</a> 的项目中下载代码。<pre><code class="bash">git clone https://github.com/DeemOpen/zkui.git</code></pre></li><li>执行 <code>mvn clean install</code> 生成jar文件。</li><li>将config.cfg复制到上一步生成的jar文件所在目录，然后修改配置文件中的zookeeper地址。</li><li>执行 <code>nohup java -jar zkui-2.0-SNAPSHOT-jar-with-dependencies.jar &amp;</code></li><li>测试 <code>http://localhost:9090</code>，如果能看到如下页面，表示安装成功。</li></ol><p><img src="http://img.xiangzhangshugongyi.com/Fherw3peRgh-grmGz6qkNri5J1aG.png" alt="登录页面"><br><img src="http://img.xiangzhangshugongyi.com/FvEVMOzSZBP4N4-Q14noQT_VsKF6.png" alt="首页"></p><h2 id="三-使用dubbo"><a href="#三-使用dubbo" class="headerlink" title="三.使用dubbo"></a>三.使用dubbo</h2><ol><li><p>在原来 SpringMVC+Spring+Mybatis 项目中，除了原来 spring 相关依赖外，还需要加入以下依赖</p><pre><code class="xml">&lt;dependency&gt;     &lt;groupId&gt;com.alibaba&lt;/groupId&gt;     &lt;artifactId&gt;dubbo&lt;/artifactId&gt;     &lt;version&gt;2.5.5&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;     &lt;groupId&gt;org.apache.zookeeper&lt;/groupId&gt;     &lt;artifactId&gt;zookeeper&lt;/artifactId&gt;     &lt;version&gt;3.4.9&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;     &lt;groupId&gt;com.101tec&lt;/groupId&gt;     &lt;artifactId&gt;zkclient&lt;/artifactId&gt;     &lt;version&gt;0.2&lt;/version&gt;&lt;/dependency&gt;</code></pre></li><li><p>定义服务接口</p><pre><code class="java">public interface IPersonService { List&lt;Person&gt; listAll(); Person getById(Integer id); Integer delById(Person person); Integer updatePerson(Person person);}</code></pre></li><li><p>定义服务实现类</p><pre><code class="java">@Servicepublic class PersonService implements IPersonService { @Autowired PersonMapper personMapper; public List&lt;Person&gt; listAll() {     return personMapper.findAll(); } public Person getById(Integer id) {     return personMapper.findOneById(id); } public Integer delById(Person person) {     return personMapper.del(person); } public Integer updatePerson(Person person) {     return personMapper.update(person); }}</code></pre></li><li><p>配置生产者，注册服务信息</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;    xmlns:dubbo=&quot;http://code.alibabatech.com/schema/dubbo&quot;    xmlns=&quot;http://www.springframework.org/schema/beans&quot;    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd&quot;&gt; &lt;!--定义了提供方应用信息，用于计算依赖关系；--&gt; &lt;dubbo:application name=&quot;demotest-provider&quot; /&gt; &lt;!-- 使用 zookeeper 注册中心暴露服务地址 --&gt; &lt;dubbo:registry address=&quot;zookeeper://192.168.0.86:2181&quot;/&gt; &lt;!-- 用dubbo协议在20880端口暴露服务 --&gt; &lt;dubbo:protocol name=&quot;dubbo&quot; port=&quot;20880&quot;/&gt; &lt;!-- 和本地bean一样实现服务 --&gt; &lt;bean id=&quot;personService&quot; class=&quot;com.ssm.service.PersonService&quot;/&gt; &lt;!-- 声明需要暴露的服务接口 --&gt; &lt;dubbo:service interface=&quot;com.ssm.iservice.IPersonService&quot; ref=&quot;personService&quot;/&gt;&lt;/beans&gt;</code></pre></li><li><p>配置消费者，订阅服务</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;    xmlns:dubbo=&quot;http://code.alibabatech.com/schema/dubbo&quot;    xmlns=&quot;http://www.springframework.org/schema/beans&quot;    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd&quot;&gt; &lt;!-- 消费方应用名，用于计算依赖关系，不是匹配条件，不要与提供方一样 --&gt; &lt;dubbo:application name=&quot;demo-consumer&quot;/&gt; &lt;!-- 使用 zookeeper 注册中心暴露发现服务地址 --&gt; &lt;dubbo:registry address=&quot;zookeeper://192.168.0.86:2181&quot;/&gt; &lt;!-- 生成远程服务代理，可以和本地bean一样使用demoService --&gt; &lt;dubbo:reference id=&quot;personService&quot; check=&quot;false&quot; interface=&quot;com.ssm.iservice.IPersonService&quot;/&gt;&lt;/beans&gt;</code></pre></li><li><p>调用远程服务<br>配置完成后，我们就可以像使用本地 bean 一样，使用 rpc 的 service；</p><pre><code class="java">@Controllerpublic class IndexController { @Autowired IPersonService personService; @RequestMapping(&quot;/index.html&quot;) public String index(Model model) {     RpcContext.getContext().setAttachment(&quot;index&quot;, &quot;1&quot;);//测试ThreadLocal     List&lt;Person&gt; list = personService.listAll();     model.addAttribute(&quot;command&quot;,list);     return &quot;index&quot;; }}</code></pre></li></ol><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>至此，单机运行的 rpc 服务已搭建完成。</p><p>代码传送文 <a href="https://github.com/yelog/ssm" target="_blank" rel="noopener">ssm</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="后端" scheme="https://jiangxingye.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="dubbo" scheme="https://jiangxingye.github.io/tags/dubbo/"/>
    
      <category term="zookeeper" scheme="https://jiangxingye.github.io/tags/zookeeper/"/>
    
  </entry>
  
  <entry>
    <title>docker报错集锦</title>
    <link href="https://jiangxingye.github.io/2017/09/25/docker-errors/"/>
    <id>https://jiangxingye.github.io/2017/09/25/docker-errors/</id>
    <published>2017-09-25T02:03:50.000Z</published>
    <updated>2019-09-02T13:02:59.997Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="docker创建容器"><a href="#docker创建容器" class="headerlink" title="docker创建容器"></a>docker创建容器</h2><h3 id="1-iptables-failed"><a href="#1-iptables-failed" class="headerlink" title="1. iptables failed"></a>1. iptables failed</h3><p>创建 <code>tale</code> 容器时，如下命令：</p><pre><code class="bash">docker run -d --privileged --hostname tale --name tale \-v /etc/localtime:/etc/localtime:ro \-v /home/tale:/var/tale_home -p 127.0.0.1:234:9000 \-m 1024m --memory-swap -1 tale:1.0</code></pre><p>然后就报了以下错误：</p><pre><code class="bash">docker: Error response from daemon: driver failed programming external connectivity on endpoint tale (263775ff559176224428ec44dcec416a1c20e6c69198d9760b38f35849914260): iptables failed: iptables --wait -t nat -A DOCKER -p tcp -d 127.0.0.1 --dport 234 -j DNAT --to-destination 172.17.0.4:9000 ! -i docker0: iptables: No chain/target/match by that name. (exit status 1).</code></pre><p>解决办法：重启 docker 服务：</p><pre><code class="bash">$ service docker restart</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="运维" scheme="https://jiangxingye.github.io/categories/%E8%BF%90%E7%BB%B4/"/>
    
    
      <category term="docker" scheme="https://jiangxingye.github.io/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>[转]浏览器前进/后退缓存（BF Cache）</title>
    <link href="https://jiangxingye.github.io/2017/09/21/bf-cache/"/>
    <id>https://jiangxingye.github.io/2017/09/21/bf-cache/</id>
    <published>2017-09-21T07:35:24.000Z</published>
    <updated>2019-09-02T13:02:59.991Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><hr>[浏览器前进/后退缓存](https://developer.mozilla.org/en-US/docs/Working_with_BFCache)（Backward/Forward Cache，BF Cache）是指浏览器在前进后退过程中， 会应用更强的缓存策略，表现为 DOM、window、甚至 JavaScript 对象被缓存，以及同步 XHR 也被缓存。 这一现象在移动端浏览器尤为常见，除 Chrome for Android、Android Browser 之外的浏览器基本都会触发。<p>BF Cache 本来是一项浏览器优化，但在某些情况下（比如前端路由的 Web App）会引起困惑。 本文主要讨论 BF Cache 的行为、如何检测 BF Cache 缓存、以及如何 workaround。</p><h3 id="缓存行为"><a href="#缓存行为" class="headerlink" title="缓存行为"></a>缓存行为</h3><p>BF Cache 是一种浏览器优化，HTML 标准并未指定其如何进行缓存，因此缓存行为是与浏览器实现相关的。</p><blockquote><p>User agents may discard the Document objects of entries other than the current entry that are not referenced from any script, reloading the pages afresh when the user or script navigates back to such pages. This specification does not specify when user agents should discard Document objects and when they should cache them. – <a href="https://html.spec.whatwg.org/multipage/browsers.html#history" target="_blank" rel="noopener">Session history and navigation</a>, WHATWG</p></blockquote><ul><li>Desktop Chrome：阻塞的资源和同步发出的 XHR 都会被缓存，但不缓存渲染结果。因此可以看到明显的载入过程，此时脚本也会重新执行。</li><li>Chrome for Android：有些情况下不会缓存，缓存时与 Desktop Chrome 行为一致。</li><li>Desktop Firefox：页面会被 Frozen，定时器会被暂停，DOM、Window、JavaScript 对象会被缓存，返回时页面脚本重新开始运行。</li><li>iOS Safari：渲染结果也会被缓存，因此才能支持左右滑动手势来前进/后退。</li></ul><p>Desktop Firefox 暂停计时器的行为非常有趣，以下 HTML 中显示一个每秒加一的数字。 当页面导航时就会暂停，返回时继续增加（因此直接使用 setInterval 倒计时不仅不精确，而且不可靠）：</p><pre><code class="html">&lt;span id=&quot;timer-tick&quot;&gt;&lt;/span&gt;&lt;a href=&quot;http://harttle.com&quot;&gt;External Link&lt;/a&gt;&lt;script&gt;  var i = 0  setInterval(() =&gt; document.querySelector(&#39;#timer-tick&#39;).innerHTML = i++, 1000)&lt;/script&gt;</code></pre><h3 id="pagehide-pageshow-事件"><a href="#pagehide-pageshow-事件" class="headerlink" title="pagehide/pageshow 事件"></a>pagehide/pageshow 事件</h3><p>会话（Session）中的某一个页面显示/隐藏时，会触发 <code>pagehide</code> 和 <code>pageshow</code> 事件。 这两个事件都有一个 <code>persisted</code> 属性用来指示当前页面是否被 BF Cache 缓存。 因此可以通过 <code>persisted</code> 属性来达到禁用 BF Cache 的效果：</p><pre><code class="javascript">window.onpageshow = function(event) {    if (event.persisted) {        window.location.reload()    }};</code></pre><p>注意无论页面是否被缓存 <code>pageshow</code> 总会触发，因此需要检测器 <code>persisted</code> 属性。 另外 <code>pageshow</code> 的时机总是在 <code>load</code> 事件之后。 这一点很容易检测，下面的 <code>pageshow</code> 日志总在 <code>load</code> 之前：</p><pre><code class="javascript">window.addEventListener(&#39;pageshow&#39;, function () {  console.log(&#39;on pageshow&#39;)})window.addEventListener(&#39;load&#39;, function () {  console.log(&#39;load&#39;)})</code></pre><h3 id="XHR-缓存"><a href="#XHR-缓存" class="headerlink" title="XHR 缓存"></a>XHR 缓存</h3><p>同步（阻塞加载的）脚本发出的 XMLHttpRequest 也会被 Chrome 强制缓存， 因此即使在断网的情况下后退到访问过的页面仍然是可以完美渲染的。 如果页面中有这样一段外部脚本：</p><pre><code class="javascript">sendXHR();function sendXHR () {  var xhr = new XMLHttpRequest()  xhr.open(&#39;GET&#39;, &#39;/data.json&#39;)  xhr.onreadystatechange = function () {    if (xhr.readyState === XMLHttpRequest.DONE &amp;&amp;     xhr.status === 200) {      console.log(&#39;xhr arrived&#39;, xhr.responseText)    }  }  xhr.send()}</code></pre><p>超链接跳转后回来，该 xhr 也会被缓存。注意下图中的 XHR 一项 size 为 “from disk cache”：<br><img src="http://img.xiangzhangshugongyi.com/FiUT28A3DCpwPiyvJpsvhkdFQai1.png" alt></p><p>为了强制发送 xhr，可以将 xhr 改为异步发送，或者加一个不重要的 query。</p><pre><code class="javascript">setTimeout(sendXHR, 1000)</code></pre><p>这样就能看到 xhr 真正发送出去了 :) 异步 xhr 缓存时机未经兼容性测试， 还是建议读者使用一个随机产生的 query。<br><img src="http://img.xiangzhangshugongyi.com/FjwUrogpYSRjC5EGPGIH2x1t2Eff.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="大前端" scheme="https://jiangxingye.github.io/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="js" scheme="https://jiangxingye.github.io/tags/js/"/>
    
      <category term="浏览器" scheme="https://jiangxingye.github.io/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
  </entry>
  
</feed>
