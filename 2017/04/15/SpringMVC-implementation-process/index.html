<!DOCTYPE html>





<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.9.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.4.0">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.4.0">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.4.0">
  <link rel="mask-icon" href="/images/logo.svg?v=7.4.0" color="#222">
  <link rel="alternate" href="/atom.xml" title="姜兴业非官方网站" type="application/atom+xml">

<link rel="stylesheet" href="/css/main.css?v=7.4.0">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '7.4.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: 'Kopieren',
      copy_success: 'Kopiert',
      copy_failure: 'Kopieren fehlgeschlagen'
    },
    sidebarPadding: 40
  };
</script>

  <meta name="description" content="在SpringMVC中主要是围绕着DispatcherServlet来设计，可以把它当做指挥中心。这里先说明一下SpringMVC文档给出的执行流程，然后是我们稍微具体的执行流程，最后是流程大致的源码跟踪。关于很很很详细的源码解析，这里暂先不做。 官方文档中的流程首先看下SpringMVC文档上给的流程图：这张图片给了我们大概的执行流程：  用户请求首先发送到前端控制器DispatcherServ">
<meta name="keywords" content="java,spring,springmvc">
<meta property="og:type" content="article">
<meta property="og:title" content="[转]SpringMVC执行流程及源码解析">
<meta property="og:url" content="https://jiangxingye.github.io/2017/04/15/SpringMVC-implementation-process/index.html">
<meta property="og:site_name" content="姜兴业非官方网站">
<meta property="og:description" content="在SpringMVC中主要是围绕着DispatcherServlet来设计，可以把它当做指挥中心。这里先说明一下SpringMVC文档给出的执行流程，然后是我们稍微具体的执行流程，最后是流程大致的源码跟踪。关于很很很详细的源码解析，这里暂先不做。 官方文档中的流程首先看下SpringMVC文档上给的流程图：这张图片给了我们大概的执行流程：  用户请求首先发送到前端控制器DispatcherServ">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://img.xiangzhangshugongyi.com/DispatcherServlet.png">
<meta property="og:updated_time" content="2019-09-02T13:02:59.978Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="[转]SpringMVC执行流程及源码解析">
<meta name="twitter:description" content="在SpringMVC中主要是围绕着DispatcherServlet来设计，可以把它当做指挥中心。这里先说明一下SpringMVC文档给出的执行流程，然后是我们稍微具体的执行流程，最后是流程大致的源码跟踪。关于很很很详细的源码解析，这里暂先不做。 官方文档中的流程首先看下SpringMVC文档上给的流程图：这张图片给了我们大概的执行流程：  用户请求首先发送到前端控制器DispatcherServ">
<meta name="twitter:image" content="http://img.xiangzhangshugongyi.com/DispatcherServlet.png">
  <link rel="canonical" href="https://jiangxingye.github.io/2017/04/15/SpringMVC-implementation-process/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true,
    isPage: false,
    isArchive: false
  };
</script>

  <title>[转]SpringMVC执行流程及源码解析 | 姜兴业非官方网站</title>
  








  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">
  <div class="container use-motion">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">姜兴业非官方网站</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <button aria-label="Navigationsleiste an/ausschalten">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
      
      
      
        
        <li class="menu-item menu-item-home">
      
    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>Startseite</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-archives">
      
    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>Archiv</a>

  </li>
  </ul>

    

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
      <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block post">
    <link itemprop="mainEntityOfPage" href="https://jiangxingye.github.io/2017/04/15/SpringMVC-implementation-process/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="姜兴业">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="姜兴业非官方网站">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">[转]SpringMVC执行流程及源码解析

          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Veröffentlicht am</span>

              
                
              

              <time title="Erstellt: 2017-04-15 10:22:05" itemprop="dateCreated datePublished" datetime="2017-04-15T10:22:05+08:00">2017-04-15</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Bearbeitet am</span>
                <time title="Geändert am: 2019-09-02 21:02:59" itemprop="dateModified" datetime="2019-09-02T21:02:59+08:00">2019-09-02</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">in</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/后端/" itemprop="url" rel="index"><span itemprop="name">后端</span></a></span>

                
                
              
            </span>
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>在SpringMVC中主要是围绕着DispatcherServlet来设计，可以把它当做指挥中心。这里先说明一下SpringMVC文档给出的执行流程，然后是我们稍微具体的执行流程，最后是流程大致的源码跟踪。关于很很很详细的源码解析，这里暂先不做。</p>
<h2 id="官方文档中的流程"><a href="#官方文档中的流程" class="headerlink" title="官方文档中的流程"></a>官方文档中的流程</h2><p>首先看下SpringMVC文档上给的流程图：<br><img src="http://img.xiangzhangshugongyi.com/DispatcherServlet.png" alt="官方流程图"><br>这张图片给了我们大概的执行流程：</p>
<ol>
<li>用户请求首先发送到前端控制器DispatcherServlet，DispatcherServlet根据请求的信息来决定使用哪个页面控制器Controller（也就是我们通常编写的Controller）来处理该请求。找到控制器之后，DispatcherServlet将请求委托给控制器去处理。</li>
<li>接下来页面控制器开始处理用户请求，页面控制器会根据请求信息进行处理，调用业务层等等，处理完成之后，会把结果封装成一个ModelAndView返回给DispatcherServlet。</li>
<li>前端控制器DispatcherServlet接到页面控制器的返回结果后，根据返回的视图名选择相应的试图模板，并根据返回的数据进行渲染。</li>
<li>最后前端控制器DispatcherServlet将结果返回给用户。</li>
</ol>
<h2 id="更具体的流程"><a href="#更具体的流程" class="headerlink" title="更具体的流程"></a>更具体的流程</h2><p>上面只是总体流程，接下来我们稍微深入一点，看下更具体的流程，这里没有图，只有步骤解析：</p>
<ol>
<li>用户请求发送到前端控制器DispatcherServlet。</li>
<li>前端控制器DispatcherServlet接收到请求后，DispatcherServlet会使用HandlerMapping来处理，HandlerMapping会查找到具体进行处理请求的Handler对象。</li>
<li>HandlerMapping找到对应的Handler之后，并不是返回一个Handler原始对象，而是一个Handler执行链，在这个执行链中包括了拦截器和处理请求的Handler。HandlerMapping返回一个执行链给DispatcherServlet。</li>
<li>DispatcherServlet接收到执行链之后，会调用Handler适配器去执行Handler。</li>
<li>Handler适配器执行完成Handler（也就是我们写的Controller）之后会得到一个ModelAndView，并返回给DispatcherServlet。</li>
<li>DispatcherServlet接收到Handler适配器返回的ModelAndView之后，会根据其中的视图名调用视图解析器。</li>
<li>视图解析器根据逻辑视图名解析成一个真正的View视图，并返回给DispatcherServlet。</li>
<li>DispatcherServlet接收到视图之后，会根据上面的ModelAndView中的model来进行视图中数据的填充，也就是所谓的视图渲染。</li>
<li>渲染完成之后，DispatcherServlet就可以将结果返回给用户了。</li>
</ol>
<h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p>DispatcherServlet是一个Servlet，我们知道在Servlet在处理一个请求的时候会交给service方法进行处理，这里也不例外，DispatcherServlet继承了FrameworkServlet，首先进入FrameworkServlet的service方法：</p>
<pre><code class="java">protected void service(HttpServletRequest request, HttpServletResponse response)
        throws ServletException, IOException {
    //请求方法
    String method = request.getMethod();
    //PATCH方法单独处理
    if (method.equalsIgnoreCase(RequestMethod.PATCH.name())) {
        processRequest(request, response);
    }
    else {//其他的请求类型的方法经由父类，也就是HttpServlet处理
        super.service(request, response);
    }
}
</code></pre>
<p>HttpServlet中会根据请求类型的不同分别调用doGet或者doPost等方法，FrameworkServlet中已经重写了这些方法，在这些方法中会调用processRequest进行处理，在processRequest中会调用doService方法，这个doService方法就是在DispatcherServlet中实现的。下面就看下DispatcherServlet中的doService方法的实现。</p>
<h3 id="请求到达DispatcherServlet"><a href="#请求到达DispatcherServlet" class="headerlink" title="请求到达DispatcherServlet"></a>请求到达DispatcherServlet</h3><p>doService方法：</p>
<pre><code class="java">protected void doService(HttpServletRequest request, HttpServletResponse response) throws Exception {

    //给request中的属性做一份快照
    Map&lt;String, Object&gt; attributesSnapshot = null;
    if (WebUtils.isIncludeRequest(request)) {
        logger.debug(&quot;Taking snapshot of request attributes before include&quot;);
        attributesSnapshot = new HashMap&lt;String, Object&gt;();
        Enumeration&lt;?&gt; attrNames = request.getAttributeNames();
        while (attrNames.hasMoreElements()) {
            String attrName = (String) attrNames.nextElement();
            if (this.cleanupAfterInclude || attrName.startsWith(&quot;org.springframework.web.servlet&quot;)) {
                attributesSnapshot.put(attrName, request.getAttribute(attrName));
            }
        }
    }

    //如果我们没有配置类似本地化或者主题的处理器之类的
    //SpringMVC会使用默认的值
    //默认配置文件是DispatcherServlet.properties
    request.setAttribute(WEB_APPLICATION_CONTEXT_ATTRIBUTE, getWebApplicationContext());
    request.setAttribute(LOCALE_RESOLVER_ATTRIBUTE, this.localeResolver);
    request.setAttribute(THEME_RESOLVER_ATTRIBUTE, this.themeResolver);
    request.setAttribute(THEME_SOURCE_ATTRIBUTE, getThemeSource());

    FlashMap inputFlashMap = this.flashMapManager.retrieveAndUpdate(request, response);
    if (inputFlashMap != null) {
        request.setAttribute(INPUT_FLASH_MAP_ATTRIBUTE, Collections.unmodifiableMap(inputFlashMap));
    }
    request.setAttribute(OUTPUT_FLASH_MAP_ATTRIBUTE, new FlashMap());
    request.setAttribute(FLASH_MAP_MANAGER_ATTRIBUTE, this.flashMapManager);

    try {
        //开始处理
        doDispatch(request, response);
    }
    finally {
        if (WebAsyncUtils.getAsyncManager(request).isConcurrentHandlingStarted()) {
            return;
        }
        // Restore the original attribute snapshot, in case of an include.
        if (attributesSnapshot != null) {
            restoreAttributesAfterInclude(request, attributesSnapshot);
        }
    }
}
</code></pre>
<p>DispatcherServlet开始真正的处理，doDispatch方法：</p>
<pre><code class="java">protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception {
    HttpServletRequest processedRequest = request;
    HandlerExecutionChain mappedHandler = null;
    boolean multipartRequestParsed = false;
    //SpringMVC中异步请求的相关知识，暂先不解释
    WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);

    try {
        ModelAndView mv = null;
        Exception dispatchException = null;

        try {
            //先检查是不是Multipart类型的，比如上传等
            //如果是Multipart类型的，则转换为MultipartHttpServletRequest类型
            processedRequest = checkMultipart(request);
            multipartRequestParsed = processedRequest != request;

            //获取当前请求的Handler
            mappedHandler = getHandler(processedRequest, false);
            if (mappedHandler == null || mappedHandler.getHandler() == null) {
                noHandlerFound(processedRequest, response);
                return;
            }

            //获取当前请求的Handler适配器
            HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());

            // 对于header中last-modified的处理
            String method = request.getMethod();
            boolean isGet = &quot;GET&quot;.equals(method);
            if (isGet || &quot;HEAD&quot;.equals(method)) {
                long lastModified = ha.getLastModified(request, mappedHandler.getHandler());
                if (new ServletWebRequest(request, response).checkNotModified(lastModified) &amp;&amp; isGet) {
                    return;
                }
            }
            //拦截器的preHandle方法进行处理
            if (!mappedHandler.applyPreHandle(processedRequest, response)) {
                return;
            }

            try {
                //真正调用Handler的地方
                mv = ha.handle(processedRequest, response, mappedHandler.getHandler());
            }
            finally {
                if (asyncManager.isConcurrentHandlingStarted()) {
                    return;
                }
            }
            //处理成默认视图名，就是添加前缀和后缀等
            applyDefaultViewName(request, mv);
            //拦截器postHandle方法进行处理
            mappedHandler.applyPostHandle(processedRequest, response, mv);
        }
        catch (Exception ex) {
            dispatchException = ex;
        }
        //处理最后的结果，渲染之类的都在这里
        processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);
    }
    catch (Exception ex) {
        triggerAfterCompletion(processedRequest, response, mappedHandler, ex);
    }
    catch (Error err) {
        triggerAfterCompletionWithError(processedRequest, response, mappedHandler, err);
    }
    finally {
        if (asyncManager.isConcurrentHandlingStarted()) {
            // Instead of postHandle and afterCompletion
            mappedHandler.applyAfterConcurrentHandlingStarted(processedRequest, response);
            return;
        }
        // Clean up any resources used by a multipart request.
        if (multipartRequestParsed) {
            cleanupMultipart(processedRequest);
        }
    }
}
</code></pre>
<p>可以看到大概的步骤还是按照我们上面分析的走的。</p>
<h3 id="查找请求对应的Handler对象"><a href="#查找请求对应的Handler对象" class="headerlink" title="查找请求对应的Handler对象"></a>查找请求对应的Handler对象</h3><p>对应着这句代码 <code>mappedHandler = getHandler(processedRequest, false);</code>，看下具体的getHandler方法：</p>
<pre><code class="java">protected HandlerExecutionChain getHandler(HttpServletRequest request, boolean cache) throws Exception {
    return getHandler(request);
}
</code></pre>
<p>继续往下看getHandler：</p>
<pre><code class="java">protected HandlerExecutionChain getHandler(HttpServletRequest request) throws Exception {
    //遍历所有的handlerMappings进行处理
    //handlerMappings是在启动的时候预先注册好的
    for (HandlerMapping hm : this.handlerMappings) {
        HandlerExecutionChain handler = hm.getHandler(request);
        if (handler != null) {
            return handler;
        }
    }
    return null;
}
</code></pre>
<p>继续往下看getHandler，在AbstractHandlerMapping类中：</p>
<pre><code class="java">public final HandlerExecutionChain getHandler(HttpServletRequest request) throws Exception {
    //根据request获取handler
    Object handler = getHandlerInternal(request);
    if (handler == null) {
        //如果没有找到就使用默认的handler
        handler = getDefaultHandler();
    }
    if (handler == null) {
        return null;
    }
    //如果Handler是String，表明是一个bean名称
    //需要超照对应bean
    if (handler instanceof String) {
        String handlerName = (String) handler;
        handler = getApplicationContext().getBean(handlerName);
    }
    //封装Handler执行链
    return getHandlerExecutionChain(handler, request);
}
</code></pre>
<h3 id="根据requrst获取handler"><a href="#根据requrst获取handler" class="headerlink" title="根据requrst获取handler"></a>根据requrst获取handler</h3><p>首先看下根据requrst获取handler步骤getHandlerInternal方法，在AbstractHandlerMethodMapping中：</p>
<pre><code class="java">protected HandlerMethod getHandlerInternal(HttpServletRequest request) throws Exception {
    //获取request中的url，用来匹配handler
    String lookupPath = getUrlPathHelper().getLookupPathForRequest(request);
    //根据路径寻找Handler
    HandlerMethod handlerMethod = lookupHandlerMethod(lookupPath, request);
    //根据handlerMethod中的bean来实例化Handler并添加进HandlerMethod
    return (handlerMethod != null) ? handlerMethod.createWithResolvedBean() : null;
}
</code></pre>
<p>看下根据路径寻找handler的方法lookupHandlerMethod：</p>
<pre><code class="java">protected HandlerMethod lookupHandlerMethod(String lookupPath, HttpServletRequest request) throws Exception {
    List&lt;Match&gt; matches = new ArrayList&lt;Match&gt;();
    //直接匹配
    List&lt;T&gt; directPathMatches = this.urlMap.get(lookupPath);
    //如果有匹配的，就添加进匹配列表中
    if (directPathMatches != null) {
        addMatchingMappings(directPathMatches, matches, request);
    }
    //还没有匹配的，就遍历所有的处理方法查找
    if (matches.isEmpty()) {
        // No choice but to go through all mappings
        addMatchingMappings(this.handlerMethods.keySet(), matches, request);
    }
    //找到了匹配的
    if (!matches.isEmpty()) {
        Comparator&lt;Match&gt; comparator = new MatchComparator(getMappingComparator(request));
        Collections.sort(matches, comparator);
        //排序之后，获取第一个
        Match bestMatch = matches.get(0);
        //如果有多个匹配的，会找到第二个最合适的进行比较一下
        if (matches.size() &gt; 1) {
            Match secondBestMatch = matches.get(1);
            if (comparator.compare(bestMatch, secondBestMatch) == 0) {
                Method m1 = bestMatch.handlerMethod.getMethod();
                Method m2 = secondBestMatch.handlerMethod.getMethod();
                throw new IllegalStateException(
                        &quot;Ambiguous handler methods mapped for HTTP path &#39;&quot; + request.getRequestURL() + &quot;&#39;: {&quot; +
                        m1 + &quot;, &quot; + m2 + &quot;}&quot;);
            }
        }
        //设置request参数
        handleMatch(bestMatch.mapping, lookupPath, request);
        //返回匹配的url的处理的方法
        return bestMatch.handlerMethod;
    }
    else {//最后还没有找到，返回null
        return handleNoMatch(handlerMethods.keySet(), lookupPath, request);
    }
}
</code></pre>
<h3 id="获取默认Handler"><a href="#获取默认Handler" class="headerlink" title="获取默认Handler"></a>获取默认Handler</h3><p>如果上面没有获取到Handler，就会获取默认的Handler。如果还获取不到就返回null。</p>
<h3 id="处理String类型的Handler"><a href="#处理String类型的Handler" class="headerlink" title="处理String类型的Handler"></a>处理String类型的Handler</h3><p>如果上面处理完的Handler是String类型的，就会根据这个handlerName获取bean。</p>
<h3 id="封装Handler执行链"><a href="#封装Handler执行链" class="headerlink" title="封装Handler执行链"></a>封装Handler执行链</h3><p>上面获取完Handler，就开始封装执行链了，就是将我们配置的拦截器加入到执行链中去，getHandlerExecutionChain：</p>
<pre><code class="java">protected HandlerExecutionChain getHandlerExecutionChain(Object handler, HttpServletRequest request) {
    //如果当前Handler不是执行链类型，就使用一个新的执行链实例封装起来
    HandlerExecutionChain chain =
        (handler instanceof HandlerExecutionChain) ?
            (HandlerExecutionChain) handler : new HandlerExecutionChain(handler);
    //先获取适配类型的拦截器添加进去拦截器链
    chain.addInterceptors(getAdaptedInterceptors());
    //当前的url
    String lookupPath = urlPathHelper.getLookupPathForRequest(request);
    //遍历拦截器，找到跟当前url对应的，添加进执行链中去
    for (MappedInterceptor mappedInterceptor : mappedInterceptors) {
        if (mappedInterceptor.matches(lookupPath, pathMatcher)) {
            chain.addInterceptor(mappedInterceptor.getInterceptor());
        }
    }

    return chain;
}
</code></pre>
<h3 id="获取对应请求的Handler适配器"><a href="#获取对应请求的Handler适配器" class="headerlink" title="获取对应请求的Handler适配器"></a>获取对应请求的Handler适配器</h3><p>getHandlerAdapter：</p>
<pre><code class="java">protected HandlerAdapter getHandlerAdapter(Object handler) throws ServletException {
    //遍历所有的HandlerAdapter，找到和当前Handler匹配的就返回
    //我们这里会匹配到RequestMappingHandlerAdapter
    for (HandlerAdapter ha : this.handlerAdapters) {
        if (ha.supports(handler)) {
            return ha;
        }
    }
}
</code></pre>
<h3 id="缓存的处理"><a href="#缓存的处理" class="headerlink" title="缓存的处理"></a>缓存的处理</h3><p>也就是对last-modified的处理</p>
<h3 id="执行拦截器的preHandle方法"><a href="#执行拦截器的preHandle方法" class="headerlink" title="执行拦截器的preHandle方法"></a>执行拦截器的preHandle方法</h3><p>就是遍历所有的我们定义的interceptor，执行preHandle方法</p>
<h3 id="使用Handler适配器执行当前的Handler"><a href="#使用Handler适配器执行当前的Handler" class="headerlink" title="使用Handler适配器执行当前的Handler"></a>使用Handler适配器执行当前的Handler</h3><p>ha.handle执行当前Handler，我们这里使用的是RequestMappingHandlerAdapter，首先会进入AbstractHandlerMethodAdapter的handle方法：</p>
<pre><code class="java">public final ModelAndView handle(HttpServletRequest request, HttpServletResponse response, Object handler)
        throws Exception {
    return handleInternal(request, response, (HandlerMethod) handler);
}
</code></pre>
<p>handleInternal方法，在RequestMappingHandlerAdapter中：</p>
<pre><code class="java">protected final ModelAndView handleInternal(HttpServletRequest request,
        HttpServletResponse response, HandlerMethod handlerMethod) throws Exception {

    if (getSessionAttributesHandler(handlerMethod).hasSessionAttributes()) {
        // Always prevent caching in case of session attribute management.
        checkAndPrepare(request, response, this.cacheSecondsForSessionAttributeHandlers, true);
    }
    else {
        // Uses configured default cacheSeconds setting.
        checkAndPrepare(request, response, true);
    }

    // Execute invokeHandlerMethod in synchronized block if required.
    if (this.synchronizeOnSession) {
        HttpSession session = request.getSession(false);
        if (session != null) {
            Object mutex = WebUtils.getSessionMutex(session);
            synchronized (mutex) {
                return invokeHandleMethod(request, response, handlerMethod);
            }
        }
    }
    //执行方法，封装ModelAndView
    return invokeHandleMethod(request, response, handlerMethod);
}
</code></pre>
<h3 id="组装默认视图名称"><a href="#组装默认视图名称" class="headerlink" title="组装默认视图名称"></a>组装默认视图名称</h3><p>前缀和后缀名都加上</p>
<h3 id="执行拦截器的postHandle方法"><a href="#执行拦截器的postHandle方法" class="headerlink" title="执行拦截器的postHandle方法"></a>执行拦截器的postHandle方法</h3><p>遍历intercepter的postHandle方法。</p>
<h3 id="处理最后的结果，渲染之类的"><a href="#处理最后的结果，渲染之类的" class="headerlink" title="处理最后的结果，渲染之类的"></a>处理最后的结果，渲染之类的</h3><p>processDispatchResult方法：</p>
<pre><code class="java">private void processDispatchResult(HttpServletRequest request, HttpServletResponse response,
        HandlerExecutionChain mappedHandler, ModelAndView mv, Exception exception) throws Exception {

    boolean errorView = false;

    if (exception != null) {
        if (exception instanceof ModelAndViewDefiningException) {
            mv = ((ModelAndViewDefiningException) exception).getModelAndView();
        }
        else {
            Object handler = (mappedHandler != null ? mappedHandler.getHandler() : null);
            mv = processHandlerException(request, response, handler, exception);
            errorView = (mv != null);
        }
    }

    // Did the handler return a view to render?
    if (mv != null &amp;&amp; !mv.wasCleared()) {
        //渲染
        render(mv, request, response);
        if (errorView) {
            WebUtils.clearErrorRequestAttributes(request);
        }
    }
    else {
    }

    if (WebAsyncUtils.getAsyncManager(request).isConcurrentHandlingStarted()) {
        // Concurrent handling started during a forward
        return;
    }

    if (mappedHandler != null) {
        mappedHandler.triggerAfterCompletion(request, response, null);
    }
}
</code></pre>
<p>重点看下render方法，进行渲染：</p>
<pre><code class="java">protected void render(ModelAndView mv, HttpServletRequest request, HttpServletResponse response) throws Exception {
    //设置本地化
    Locale locale = this.localeResolver.resolveLocale(request);
    response.setLocale(locale);

    View view;
    if (mv.isReference()) {
        //解析视图名，得到视图
        view = resolveViewName(mv.getViewName(), mv.getModelInternal(), locale, request);
    }
    else {
        // No need to lookup: the ModelAndView object contains the actual View object.
        view = mv.getView();
        if (view == null) {
            throw new ServletException(&quot;ModelAndView [&quot; + mv + &quot;] neither contains a view name nor a &quot; +
                    &quot;View object in servlet with name &#39;&quot; + getServletName() + &quot;&#39;&quot;);
        }
    }

    //委托给视图进行渲染
    view.render(mv.getModelInternal(), request, response);
}
</code></pre>
<p>view.render就是进行视图的渲染，然后跳转页面等处理。</p>
<p>到这里大概的流程就走完了。其中涉及到的东西还有很多，暂先不做详细处理。</p>
<p>原文：<a href="http://cxis.me/2017/04/06/SpringMVC%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E5%8F%8A%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/" target="_blank" rel="noopener">SpringMVC执行流程及源码解析</a></p>

    </div>

    
    
    
        
      

      <footer class="post-footer">
          
            
          
          <div class="post-tags">
            
              <a href="/tags/java/" rel="tag"># java</a>
            
              <a href="/tags/spring/" rel="tag"># spring</a>
            
              <a href="/tags/springmvc/" rel="tag"># springmvc</a>
            
          </div>
        

        

          <div class="post-nav">
            <div class="post-nav-next post-nav-item">
              
                <a href="/2017/04/14/postgres-sql-use/" rel="next" title="PostgreSQL常用SQL操作">
                  <i class="fa fa-chevron-left"></i> PostgreSQL常用SQL操作
                </a>
              
            </div>

            <span class="post-nav-divider"></span>

            <div class="post-nav-prev post-nav-item">
              
                <a href="/2017/04/21/jsp-use-record/" rel="prev" title="JSP操作记录">
                  JSP操作记录 <i class="fa fa-chevron-right"></i>
                </a>
              
            </div>
          </div>
        
      </footer>
    
  </div>
  
  
  
  </article>

  </div>


          </div>
          

        </div>
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">
        
        
        
        
      

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Inhaltsverzeichnis
        </li>
        <li class="sidebar-nav-overview">
          Übersicht
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#官方文档中的流程"><span class="nav-number">1.</span> <span class="nav-text">官方文档中的流程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#更具体的流程"><span class="nav-number">2.</span> <span class="nav-text">更具体的流程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#源码"><span class="nav-number">3.</span> <span class="nav-text">源码</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#请求到达DispatcherServlet"><span class="nav-number">3.1.</span> <span class="nav-text">请求到达DispatcherServlet</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#查找请求对应的Handler对象"><span class="nav-number">3.2.</span> <span class="nav-text">查找请求对应的Handler对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#根据requrst获取handler"><span class="nav-number">3.3.</span> <span class="nav-text">根据requrst获取handler</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#获取默认Handler"><span class="nav-number">3.4.</span> <span class="nav-text">获取默认Handler</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#处理String类型的Handler"><span class="nav-number">3.5.</span> <span class="nav-text">处理String类型的Handler</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#封装Handler执行链"><span class="nav-number">3.6.</span> <span class="nav-text">封装Handler执行链</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#获取对应请求的Handler适配器"><span class="nav-number">3.7.</span> <span class="nav-text">获取对应请求的Handler适配器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#缓存的处理"><span class="nav-number">3.8.</span> <span class="nav-text">缓存的处理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#执行拦截器的preHandle方法"><span class="nav-number">3.9.</span> <span class="nav-text">执行拦截器的preHandle方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用Handler适配器执行当前的Handler"><span class="nav-number">3.10.</span> <span class="nav-text">使用Handler适配器执行当前的Handler</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#组装默认视图名称"><span class="nav-number">3.11.</span> <span class="nav-text">组装默认视图名称</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#执行拦截器的postHandle方法"><span class="nav-number">3.12.</span> <span class="nav-text">执行拦截器的postHandle方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#处理最后的结果，渲染之类的"><span class="nav-number">3.13.</span> <span class="nav-text">处理最后的结果，渲染之类的</span></a></li></ol></li></ol></div>
        
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">姜兴业</p>
  <div class="site-description" itemprop="description"></div>
</div>
  <nav class="site-state motion-element">
      <div class="site-state-item site-state-posts">
        
          <a href="/archives/">
        
          <span class="site-state-item-count">113</span>
          <span class="site-state-item-name">Artikel</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-categories">
        
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">Kategorien</span>
        
      </div>
    
      
      
      <div class="site-state-item site-state-tags">
        
        <span class="site-state-item-count">45</span>
        <span class="site-state-item-name">schlagwörter</span>
        
      </div>
    
  </nav>
  <div class="feed-link motion-element">
    <a href="/atom.xml" rel="alternate">
      <i class="fa fa-rss"></i>RSS
    </a>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">姜兴业</span>
</div>
  <div class="powered-by">Erstellt mit  <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> v3.9.0</div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">Design – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> v7.4.0</div>

        












        
      </div>
    </footer>
  </div>

  


  <script src="/lib/anime.min.js?v=3.1.0"></script>
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
<script src="/js/utils.js?v=7.4.0"></script><script src="/js/motion.js?v=7.4.0"></script>
<script src="/js/schemes/muse.js?v=7.4.0"></script>
<script src="/js/next-boot.js?v=7.4.0"></script>



  





















  

  

  

</body>
</html>
